<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>场景算法</title>
      <link href="/2024/chang-jing-suan-fa/"/>
      <url>/2024/chang-jing-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="任务队列的中断和恢复"><a href="#任务队列的中断和恢复" class="headerlink" title="任务队列的中断和恢复"></a>任务队列的中断和恢复</h2><blockquote><p>依次顺序执行一系列任务<br>所有任务全部完成后可以得到每个任务的执行结果<br>需要返回两个方法，start 用于启动任务，pause 用于暂停任务<br>每个任务具有原子性，即不可中断，只能在两个任务之间中断</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;** * @params tasks 任务列表，每个任务无参，异步 *&#x2F;function processTasks(...tasks) &#123;  &#x2F;&#x2F; 是否暂停  let isRunning &#x3D; false;  &#x2F;&#x2F; 结果  const result &#x3D; [];  &#x2F;&#x2F; 当前执行任务的索引  let index &#x3D; 0;  return &#123;    start: () &#x3D;&gt; &#123;      return new Promise(        async (resolve) &#x3D;&gt; &#123;          if (isRunning) &#123;            return;          &#125;          isRunning &#x3D; true;          while (index &lt; tasks.length) &#123;            const task &#x3D; tasks[index];            const res &#x3D; await task();            index++;            if (!isRunning) &#123;              return;            &#125;            result.push(res);          &#125;          isRunning &#x3D; false;          resolve(result);        &#125;      );    &#125;,    pause: () &#x3D;&gt; &#123;      isRunning &#x3D; false;    &#125;,  &#125;;&#125;&#x2F;&#x2F; 实例const tasks &#x3D; [];for (let i &#x3D; 0; i &lt; 5; i++) &#123;  tasks.push(() &#x3D;&gt; &#123;    console.log(&#96;任务$&#123;i + 1&#125;开始&#96;);    return new Promise((resolve) &#x3D;&gt; &#123;      setTimeout(() &#x3D;&gt; &#123;        resolve(i);        console.log(&#96;任务$&#123;i + 1&#125;结束&#96;);      &#125;, 2000);    &#125;);  &#125;);&#125;const process &#x3D; processTasks(...tasks);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><blockquote><p>start 方法中为什么要用 Promise 而不用 async?<br>是因为如果 start 方法定义为 async,函数内部 return 的时候会直接返回一个已完成的 promise,已完成的话，则不能再继续执行，所以需要使用 new Promise</p></blockquote></blockquote><h2 id="实现一个-Promise-half-方法，当执行成功一半之后就返回结果"><a href="#实现一个-Promise-half-方法，当执行成功一半之后就返回结果" class="headerlink" title="实现一个 Promise.half 方法，当执行成功一半之后就返回结果"></a>实现一个 Promise.half 方法，当执行成功一半之后就返回结果</h2><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">Promise.half &#x3D; (tasks) &#x3D;&gt; &#123;  return new Promise(    (resolve, reject) &#x3D;&gt; &#123;      if (!Array.isArray(tasks)) &#123;        return reject(          new Error(&#39;入参必须是数组&#39;)        );      &#125;      if (!tasks.length) &#123;        resolve(null);        return;      &#125;      let mid &#x3D; tasks.length &gt;&gt; 1;      const result &#x3D; [];      let finished &#x3D; false;      for (        let i &#x3D; 0;        i &lt; tasks.length;        i++      ) &#123;        Promise.resolve(tasks[i]).then(          (res) &#x3D;&gt; &#123;            if (result.length &#x3D;&#x3D;&#x3D; mid) &#123;              finished &#x3D; true;              resolve(result);            &#125;            if (finished) &#123;              return;            &#125;            result.push(res);          &#125;        );      &#125;    &#125;  );&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="通过-proxy-实现一个监听对象及对象底层的方法"><a href="#通过-proxy-实现一个监听对象及对象底层的方法" class="headerlink" title="通过 proxy 实现一个监听对象及对象底层的方法"></a>通过 proxy 实现一个监听对象及对象底层的方法</h2><blockquote><p>通过 proxy 来实现一个“懒监听”，即监听对象所有字段，包括子对象</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const handler &#x3D; &#123;  get: (target, key, recevier) &#x3D;&gt; &#123;    const val &#x3D; Reflect.get(target,key, recevier);    if (typeof value &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; value !&#x3D;&#x3D; null)&#123;      &#x2F;&#x2F; 如果是对象并且不为空，则继续proxy代理      return new Proxy(value, handler);    &#125;    return value;  &#125;,  set: (target, key, value) &#x3D;&gt; &#123;    target[key] &#x3D; value;    return true;  &#125;&#125;new Proxy(obj, handler);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 场景算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>场景编码</title>
      <link href="/2024/chang-jing-bian-ma/"/>
      <url>/2024/chang-jing-bian-ma/</url>
      
        <content type="html"><![CDATA[<h2 id="setInterval为什么不能精确？如何做到精确"><a href="#setInterval为什么不能精确？如何做到精确" class="headerlink" title="setInterval为什么不能精确？如何做到精确"></a>setInterval为什么不能精确？如何做到精确</h2><h3 id="setInterval为什么不能精确？"><a href="#setInterval为什么不能精确？" class="headerlink" title="setInterval为什么不能精确？"></a>setInterval为什么不能精确？</h3><p>由于浏览器的event loop机制，导致不会立即执行其回调。</p><ol><li>事件循环模型影响回调执行时机</li><li>4ms最小时间（嵌套5层以上后）</li><li>失活页面间隔会被强制调整1s</li></ol><h3 id="如何精确"><a href="#如何精确" class="headerlink" title="如何精确"></a>如何精确</h3><ol><li>根据Performance.now通过时间调整间隔偏差</li><li>requestAnimationFrame（不受失活页面影响，受很多其他因素影响）</li><li>webworker(不受失活页面影响，不受渲染帧影响)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 场景编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2023/dong-tai-gui-hua/"/>
      <url>/2023/dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="多少种构建二叉树的方式"><a href="#多少种构建二叉树的方式" class="headerlink" title="[多少种构建二叉树的方式]"></a>[多少种构建二叉树的方式]</h2><p>给定一个节点数，请问有根据该节点数能构建多少种二叉树？</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 递归方式</span><span class="token keyword">function</span> <span class="token function">createTree</span><span class="token punctuation">(</span><span class="token parameter">count<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 0个节点构建空树</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">||</span> count <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> leftNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> leftNum <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> leftNum<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 左树的节点数</span>    <span class="token keyword">const</span> leftWays <span class="token operator">=</span> <span class="token function">createTree</span><span class="token punctuation">(</span>leftNum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 在右树上构建的点 就是count减去左树节点数再减去根节点数</span>    <span class="token keyword">const</span> rightWays <span class="token operator">=</span> <span class="token function">createTree</span><span class="token punctuation">(</span>count <span class="token operator">-</span> leftNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 由于左树或者右树数量变化，那么都是一颗新树，所以左树和右树的方式要相乘</span>    ans <span class="token operator">+=</span> leftWays <span class="token operator">*</span> rightWays<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 动态规划方式</span><span class="token keyword">function</span> <span class="token function">createTree</span><span class="token punctuation">(</span><span class="token parameter">count<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> leftNum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> leftNum <span class="token operator">&lt;=</span> count<span class="token punctuation">;</span> leftNum<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 当节点数位leftNum时</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> rightNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> rightNum <span class="token operator">&lt;=</span> leftNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> rightNum<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 左侧节点数位rightNum - 1,右侧节点数未 leftNum - rightNum</span>      dp<span class="token punctuation">[</span>leftNum<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>rightNum<span class="token punctuation">]</span> <span class="token operator">*</span> dp<span class="token punctuation">[</span>leftNum <span class="token operator">-</span> rightNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> dp<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符解码"><a href="#字符解码" class="headerlink" title="字符解码"></a><a href="https://leetcode.cn/problems/decode-ways/">字符解码</a></h2><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：<br>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”<br>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p><p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为 (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。<br>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。<br>题目数据保证答案肯定是一个 32 位 的整数。</p><p><strong>递归解法</strong></p><p>以 i 位置开始，计算 i 位置及其之后的字符组成有多少种可能;</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">numDecodings</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token operator">:</span> string</span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token function-variable function">process</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">str<span class="token operator">:</span> string<span class="token punctuation">,</span> index<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">===</span> str<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// index 及其之后还有数字字符</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// index 及其后续还有数字字符，且字符不是0，是1 - 9;</span>    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token function">process</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 做了一个决定，就让str[index]作为自己的一个部分</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">===</span> str<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 除了index外，后续没有字符了</span>      <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// index + 1 没有越界</span>    <span class="token comment">// index 和index + 1共同构成一个部分 &lt; 27</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>str<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>str<span class="token punctuation">[</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">27</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      res <span class="token operator">+=</span> <span class="token function">process</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>动态规划解法</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">numDecodings</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token operator">:</span> string</span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">===</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token keyword">const</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 相当于递归的index === s.length的值</span>  dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'0'</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 这里即是递归的 index + 1的可能性 + index +2的可能性</span>      <span class="token keyword">const</span> dp2 <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>s<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">27</span> <span class="token operator">?</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>      dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp2<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="/2023/hua-dong-chuang-kou/"/>
      <url>/2023/hua-dong-chuang-kou/</url>
      
        <content type="html"><![CDATA[<h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>给定一个有序数组arr, 代表数轴上从左往右有n个点arr[0]…arr[n - 1], 给定一个正数L,代表一根长度为L的绳子，求绳子最多能覆盖几个点</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">findPoint</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">L</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">L</span> <span class="token operator">></span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> cur <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 以i点定为L的左边界，然后往右，移动，移动中找到这中间覆盖的点</span>    <span class="token keyword">const</span> maxIndex <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=></span> x <span class="token operator">></span> <span class="token punctuation">(</span>cur <span class="token operator">+</span> <span class="token constant">L</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>maxIndex <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> maxIndex <span class="token operator">></span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> maxIndex <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2023/tan-xin-suan-fa/"/>
      <url>/2023/tan-xin-suan-fa/</url>
      
        <content type="html"><![CDATA[<p><strong>贪心算法:</strong></p><p>在某一个标准下，优先考虑最满足标准的样本，最后考虑不满足标准的样本，最终得到一个答案的算法，叫做贪心算法<br>也就是说，不从整体最优上加以考虑，所做出的事在某种意义上的局部最优解</p><p>局部最优 -&gt; 整体最优</p><p><strong><em>贪心算法的解题套路</em></strong></p><ol><li>实现一个不依靠贪心策略的解法 X，可以用最暴力的尝试</li><li>脑补出贪心策略 A、贪心策略 B、贪心策略 C。。。。。</li><li>用解法 X 和对数器，去验证每一个贪心策略，用实验的方式得知那个贪心策略正确</li><li>不要去纠结贪心策略的证明</li></ol><p><strong>题目</strong></p><h2 id="会议问题"><a href="#会议问题" class="headerlink" title="会议问题"></a>会议问题</h2><p>一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。<br>给你每一个项目的开始时间和结束时间（给你一个数组，里面是一个个具体的项目），你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。<br>返回这个最多的宣讲场次</p><p><strong>思路</strong></p><p>以哪个会议结束时间早，安排谁</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * @param params 项目 * @param timePoint 目前为止来到的时间点 */</span><span class="token keyword">function</span> <span class="token function">bestArrange</span><span class="token punctuation">(</span><span class="token parameter">params<span class="token punctuation">,</span> timePoint</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 将所有项目以结束时间谁早排序</span>  params<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a<span class="token punctuation">.</span>end <span class="token operator">-</span> b<span class="token punctuation">.</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 从左往右依次遍历所有会议</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> params<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 当前时间点是否小于当前待排会议的开始时间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timePoint <span class="token operator">&lt;=</span> params<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>start<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      ans<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token comment">// 将当前时间点移动到当前会议的结束时间。不断移动时间点，把不能安排的排除</span>      timePoint <span class="token operator">=</span> params<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>end<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="获取最小的水果袋"><a href="#获取最小的水果袋" class="headerlink" title="[获取最小的水果袋]"></a>[获取最小的水果袋]</h2><p>有一商家卖苹果，但是捆绑销售，只能使用装 6 个和装 8 个的袋子，现在给你一个购买苹果数 count，请你求出最少使用多少个袋子，如果不能完整装下，则返回-1;</p><p>比如: 购买 24 个苹果，最少使用 3 个袋子，即 3 个装 8 个的袋子，如果购买 25 个，则不能使用 6 个和 8 个的袋子完整装下，所以返回-1；</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">minBagBase6</span><span class="token punctuation">(</span><span class="token parameter">rest<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> rest <span class="token operator">%</span> <span class="token number">6</span> <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">?</span> rest <span class="token operator">/</span> <span class="token number">6</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">minBags</span><span class="token punctuation">(</span><span class="token parameter">count<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">let</span> use6Bags <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 优先用8尝试</span>  <span class="token keyword">let</span> use8Bags <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>count <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使用8个袋子全部装完后，剩余多少个苹果</span>  <span class="token keyword">let</span> restApple <span class="token operator">=</span> count <span class="token operator">-</span> <span class="token number">8</span> <span class="token operator">*</span> use8Bags<span class="token punctuation">;</span>  <span class="token comment">// 如果剩余苹果大于24(24是8和6的最小公倍数)，则不需要再试了，因为永远不可能装完</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>use8Bags <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> restApple <span class="token operator">&lt;</span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 使用装6个的袋子</span>    <span class="token keyword">const</span> restUse6Bags <span class="token operator">=</span> <span class="token function">minBagBase6</span><span class="token punctuation">(</span>restApple<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>restUse6Bags <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      use6Bags <span class="token operator">=</span> restUse6Bags<span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将使用8个袋子减一，再使用剩余苹果继续去使用6个袋子的试</span>    restApple <span class="token operator">=</span> count <span class="token operator">-</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token operator">--</span>use8Bags<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> use6Bags <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> use6Bags <span class="token operator">+</span> use8Bags<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> leetcode </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀树</title>
      <link href="/2023/qian-zhui-shu/"/>
      <url>/2023/qian-zhui-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍前缀树"><a href="#介绍前缀树" class="headerlink" title="介绍前缀树"></a>介绍前缀树</h2><ol><li><p>何为前缀树？</p></li><li><p>如何生成前缀树？</p></li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 前缀树节点定义</span><span class="token keyword">class</span> <span class="token class-name">TrieNode</span><span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> pass<span class="token operator">:</span> number<span class="token punctuation">;</span> <span class="token comment">// 表示创建前缀树时，经过节点多少次</span>  <span class="token keyword">public</span> end<span class="token operator">:</span> number<span class="token punctuation">;</span> <span class="token comment">// 表示创建前缀树时，到达节点多少次, 也可以理解这个字符加入过几次</span>  <span class="token keyword">public</span> nexts<span class="token operator">:</span> TrieNode<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>pass <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// nexts[0] === null  表示没有走向“a”的路</span>    <span class="token comment">// nexts[1] !== null  表示有走向“a”的路</span>    <span class="token comment">// :</span>    <span class="token comment">// :</span>    <span class="token comment">// nexts[25] !== null  表示有走向“z”的路</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>nexts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 也可以换成字典， &#123;  &#125;, key表示路的索引，值表示 节点</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 创建</span><span class="token keyword">class</span> <span class="token class-name">Trie</span><span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> root<span class="token operator">:</span> TrieNode<span class="token punctuation">;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根节点的pass 表示加入了多少个空字符串</span>  <span class="token punctuation">&#125;</span>  <span class="token function">insert</span><span class="token punctuation">(</span><span class="token parameter">word<span class="token operator">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>word<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将字符转为字符串数组</span>    <span class="token keyword">const</span> words <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>    node<span class="token punctuation">.</span>pass <span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> words<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 遍历字符串数组</span>      index <span class="token operator">=</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 由字符，对应成要走那条路，因为nexts表示要走的路</span>      <span class="token comment">// index的路上有没有节点，即有没有走向字符的路，没有就新建一个节点</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// node移动到下级的节点上</span>      node <span class="token operator">=</span> node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// 移动到下级之后，pass++，表明走了几次</span>      node<span class="token punctuation">.</span>pass <span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 最后一个节点 end++;</span>    node<span class="token punctuation">.</span>end <span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">delete</span><span class="token punctuation">(</span>word<span class="token operator">:</span> string<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> words <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>      <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      node<span class="token punctuation">.</span>pass <span class="token operator">--</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> words<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        index <span class="token operator">=</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token comment">// 如果最后一个节点的pass值为0， 则表示这个节点没用了，需要置为空，即释放这个树的分支</span>          node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>          <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        node <span class="token operator">=</span> node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      node<span class="token punctuation">.</span>end <span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 查询word这个字符之前加入过几次</span>  <span class="token function">search</span><span class="token punctuation">(</span><span class="token parameter">word<span class="token operator">:</span> string</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>word<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">const</span> words <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> words<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      index <span class="token operator">=</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      node <span class="token operator">=</span> node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> node<span class="token punctuation">.</span>end<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 所有加入过的字符中，有几个是以pre这个字符串作为前缀的</span>  <span class="token function">prefixNumber</span><span class="token punctuation">(</span><span class="token parameter">pre<span class="token operator">:</span> string</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pre<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">const</span> preWords <span class="token operator">=</span> pre<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> preWords<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      index <span class="token operator">=</span> preWords<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      node <span class="token operator">=</span> node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> node<span class="token punctuation">.</span>pass<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例:</p><p>一个字符串类型的数组 arr1,另一个字符串类型的数组 arr2</p><ul><li>arr2 中有哪些字符是在 arr1 中出现的？请打印。</li><li>arr2 中有哪些字符是作为 arr1 中某个字符串前缀出现的？请打印</li><li>arr2 中有哪些字符是作为 arr1 中某个字符串前缀出现的？请打印 arr2 中出现次数最大的前缀.</li></ul><h2 id="树形DP"><a href="#树形DP" class="headerlink" title="[树形DP]"></a>[树形DP]</h2><p>树形DP套路的使用前提是：<br>如果题目要求解目标是S规则，则求解流程可以定成以每一个节点为头节点的子树在S规则下的每一个答案，并且最终答案一定在其中</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> leetcode </tag>
            
            <tag> 树 </tag>
            
            <tag> 前缀树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图相关</title>
      <link href="/2023/tu-xiang-guan/"/>
      <url>/2023/tu-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h2 id="图的宽度按优先遍历"><a href="#图的宽度按优先遍历" class="headerlink" title="[图的宽度按优先遍历]"></a>[图的宽度按优先遍历]</h2><ol><li>利用队列实现</li><li>从源节点开始一次按照宽度进队列，然后弹出</li><li>每弹出一个点，把该节点所有没有进过队列的邻接点放入队列</li><li>直到队列变空</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * 这里的图指的无向图，即 a->b->c这种方式 * @param node 图的一个点 */</span><span class="token keyword">function</span> <span class="token function">graphBFS</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> nodeDic <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  nodeDic<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> cur <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印，其他的就在这里做业务处理</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> nextNode <span class="token keyword">of</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">[</span>nextNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        nodeDic<span class="token punctuation">[</span>nextNode<span class="token punctuation">]</span> <span class="token operator">=</span> nextNode<span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图的深度优先遍历"><a href="#图的深度优先遍历" class="headerlink" title="[图的深度优先遍历]"></a>[图的深度优先遍历]</h2><ol><li>利用栈实现</li><li>从源节点开始把节点按照深度放入栈，然后弹出</li><li>每弹出一个节点，把该节点下一个没有进过栈的邻接点放入栈</li><li>直到栈变空</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * @param node 图节点 */</span><span class="token keyword">function</span> <span class="token function">graphDFS</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> nextNode <span class="token keyword">of</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 如果没在set中，说明是一个新的节点</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 遇到新的节点，将自己和下一个从新入栈，这样最后结果就是栈中就是深度的路径</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">)</span><span class="token punctuation">;</span>        set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> leetcode </tag>
            
            <tag> 图 </tag>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/2023/ha-xi-biao/"/>
      <url>/2023/ha-xi-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="连续最长序列"><a href="#连续最长序列" class="headerlink" title="连续最长序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence">连续最长序列</a></h2><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于这里是未排序的数组，但是没有说是否有重复，姑且认为有重复元素，那么我们先对数组去重<br>利用 Set 方法去重特性，建立 Set 字典，之后循环该字典，如果当前数 - 1 在字典中，则跳过，因为小于该数的已经记录过了<br>找到数字之后，不断对其加一，判断是否在字典中，如果在，则数量加 1</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 去重</span>  <span class="token keyword">const</span> setNums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> val <span class="token keyword">of</span> setNums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果当前数-1在字典中，则跳过</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>setNums<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>val <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> curent <span class="token operator">=</span> val<span class="token punctuation">;</span>    <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 不断判断当前数+1是否在字典中，并且增加计数</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>setNums<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>curent <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      count<span class="token operator">++</span><span class="token punctuation">;</span>      curent<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 最后取计数和结果最大值</span>    ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams">字母异位词分组</a></h2><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p><p>字母异位词 是由重新排列源单词的所有字母得到的一个新单词</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span><span class="token parameter">strs<span class="token operator">:</span> string<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token operator">:</span> string<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>strs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> groupDic<span class="token operator">:</span> Record<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>strs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> cur <span class="token operator">=</span> strs<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 对字符拆分排序再还原，保证字符串key是一致的</span>    <span class="token keyword">const</span> sortStr <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>groupDic<span class="token punctuation">[</span>sortStr<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      groupDic<span class="token punctuation">[</span>sortStr<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      groupDic<span class="token punctuation">[</span>sortStr<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span>Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>groupDic<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索与回溯</title>
      <link href="/2023/sou-suo-yu-hui-su/"/>
      <url>/2023/sou-suo-yu-hui-su/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/word-search/">矩阵中的路径</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>字母迷宫游戏初始界面记作 m x n 二维字符串数组 grid，请判断玩家是否能在 grid 中找到目标单词 target。<br>注意：寻找单词时 必须 按照字母顺序，通过水平或垂直方向相邻的单元格内的字母构成，同时，同一个单元格内的字母，不允许被重复使用</p><p><img src="../../images/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF/word2.jpeg" alt="&#39;&#39;"><br>示例:<br>输入：grid = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], target = “ABCCED”<br>输出：true</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>采用 DFS 算法加剪枝处理</p><ol><li>递归参数： 当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。</li><li>终止条件：<br>返回 false ： (1) 行或列索引越界 或 (2) 当前矩阵元素与目标字符不同 或 (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ） 。<br>返回 true ： k = len(word) - 1 ，即字符串 word 已全部匹配。</li><li>递推工作：<br>标记当前矩阵元素： 将 board[i][j] 修改为 空字符 ‘’ ，代表此元素已访问过，防止之后搜索时重复访问。<br>搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 res 。还原当前矩阵元素： 将 board[i][j] 元素还原至初始值，即 word[k] 。</li><li>返回值： 返回布尔量 res ，代表是否搜索到目标字符串。</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">wordPuzzle</span><span class="token punctuation">(</span><span class="token parameter">grid<span class="token operator">:</span> string<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token operator">:</span> string</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>grid<span class="token punctuation">.</span>length <span class="token operator">||</span> <span class="token operator">!</span>target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> rowLength <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token keyword">const</span> columnLength <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token comment">// 创建一个用于记录是否使用过的数组</span>  <span class="token keyword">const</span> used<span class="token operator">:</span> boolean<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>rowLength<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>columnLength<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token function-variable function">findTargetExist</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">row<span class="token operator">:</span> number<span class="token punctuation">,</span> column<span class="token operator">:</span> number<span class="token punctuation">,</span> strIndex<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 当前索引和目标字符长度一致，则证明找到了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>strIndex <span class="token operator">===</span> target<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 处理边界情况</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>row <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> row <span class="token operator">>=</span> rowLength <span class="token operator">||</span> column <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> column <span class="token operator">>=</span> columnLength<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 题目说不能使用已使用过的，所以这里需要判断，并且如果字符不是目标字符串中的，直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>used<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>column<span class="token punctuation">]</span> <span class="token operator">||</span> grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>column<span class="token punctuation">]</span> <span class="token operator">!==</span> target<span class="token punctuation">[</span>strIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    used<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>column<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment">// 从上下左右顺序依次去查找</span>    <span class="token keyword">const</span> res <span class="token operator">=</span>      <span class="token function">findTargetExist</span><span class="token punctuation">(</span>row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> column<span class="token punctuation">,</span> strIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span>      <span class="token function">findTargetExist</span><span class="token punctuation">(</span>row <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> column<span class="token punctuation">,</span> strIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span>      <span class="token function">findTargetExist</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> column <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> strIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span>      <span class="token function">findTargetExist</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> column <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> strIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    used<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>column<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> rowLength<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> columnLength<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> curStr <span class="token operator">=</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span>curStr<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">findTargetExist</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="衣橱整理"><a href="#衣橱整理" class="headerlink" title="衣橱整理"></a><a href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">衣橱整理</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>家居整理师将待整理衣橱划分为 m x n 的二维矩阵 grid，其中 grid[i][j] 代表一个需要整理的格子。整理师自 grid[0][0] 开始 逐行逐列 地整理每个格子。<br>整理规则为：在整理过程中，可以选择 向右移动一格 或 向下移动一格，但不能移动到衣柜之外。同时，不需要整理 digit(i) + digit(j) &gt; cnt 的格子，其中 digit(x) 表示数字 x 的各数位之和。<br>请返回整理师 总共需要整理多少个格子。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>和 矩阵中的路径和相似，都是采用 dfs 加剪枝处理，如果已经整理过了的，就不需要整理了</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">wardrobeFinishing</span><span class="token punctuation">(</span><span class="token parameter">m<span class="token operator">:</span> number<span class="token punctuation">,</span> n<span class="token operator">:</span> number<span class="token punctuation">,</span> cnt<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 记录已经整理过的位置</span>  <span class="token keyword">const</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 处理数字x的和</span>  <span class="token keyword">const</span> <span class="token function-variable function">getSum</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">num<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> numArr <span class="token operator">=</span> num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> numArr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">sum<span class="token punctuation">,</span> cur</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token function">Number</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">Number</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token function-variable function">DFS</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">row<span class="token punctuation">,</span> column</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>row <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> row <span class="token operator">>=</span> m <span class="token operator">||</span> column <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> column <span class="token operator">>=</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">const</span> sum <span class="token operator">=</span> <span class="token function">getSum</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">getSum</span><span class="token punctuation">(</span>column<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>column<span class="token punctuation">]</span> <span class="token operator">||</span> sum <span class="token operator">></span> cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    visited<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>column<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    ans<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token constant">DFS</span><span class="token punctuation">(</span>row <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> column<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token constant">DFS</span><span class="token punctuation">(</span>row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> column<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token constant">DFS</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> column <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token constant">DFS</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> column <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token constant">DFS</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树相关</title>
      <link href="/2023/er-cha-shu-xiang-guan/"/>
      <url>/2023/er-cha-shu-xiang-guan/</url>
      
        <content type="html"><![CDATA[<p>定义树结构为:</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">&#123;</span>  val<span class="token operator">:</span> number<span class="token punctuation">;</span>  left<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  right<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">val<span class="token operator">?</span><span class="token operator">:</span> number<span class="token punctuation">,</span> left<span class="token operator">?</span><span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> right<span class="token operator">?</span><span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> val<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> left<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> right<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下将会直接使用该树结构</p><h2 id="二叉树的顺序打印及迭代实现"><a href="#二叉树的顺序打印及迭代实现" class="headerlink" title="[二叉树的顺序打印及迭代实现]"></a>[二叉树的顺序打印及迭代实现]</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>前序遍历的最终结果是 <strong>根-&gt;左-&gt;右</strong> 的顺序</p><p>一、<strong>递归实现</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">preOrder</span><span class="token punctuation">(</span><span class="token parameter">tree<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">preOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">preOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二、<strong>非递归实现</strong></p><p>非递归的实现采用栈的方式，即入栈之后出栈<br>流程是： 弹出栈顶，打印，之后按照 右子节点入栈，左子节点入栈的顺序再入栈，重复流程即可</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">preOrder</span><span class="token punctuation">(</span><span class="token parameter">tree<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span>tree<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    cur<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    cur<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="‘中序遍历’"><a href="#‘中序遍历’" class="headerlink" title="[‘中序遍历’]"></a>[‘中序遍历’]</h3><p>中序遍历的结果是<strong>左-&gt;根-&gt;右</strong>的顺序</p><p>一、<strong>递归实现</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token parameter">tree<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">inOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">inOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二、<strong>栈实现</strong></p><p>中序遍历的栈实现稍微复杂一点，这里的流程是<br>现在当前节点的所有左子节点入栈，入栈完成之后，再一次弹出打印，如果又有左子节点，则继续入栈<br>这里也有一个额外思路，就是树的右子节点也可以看成是他的左子结点，即右子节点就是自己的左子结点</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token parameter">tree<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">||</span> tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>      tree <span class="token operator">=</span> tree<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      tree <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 出栈就打印，这时候打印的就是中序遍历</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>      tree <span class="token operator">=</span> tree<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后续遍历"><a href="#后续遍历" class="headerlink" title="[后续遍历]"></a>[后续遍历]</h3><p>后续遍历的结果：<strong>左-&gt;右-&gt;根</strong></p><p>一、<strong>递归实现</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">posOrder</span><span class="token punctuation">(</span><span class="token parameter">tree<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">posOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">posOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二、<strong>栈实现</strong></p><p>使用栈的方式处理后续遍历，需要增加一个辅助栈，即两个栈处理，<br>栈 1 stack1 先左后右的方式入栈，在栈 1 弹出的时候，将弹出树加入栈 2 中，最后打印栈 2 的出栈顺序即可</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">posOrder</span><span class="token punctuation">(</span><span class="token parameter">tree<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> stack1 <span class="token operator">=</span> <span class="token punctuation">[</span>tree<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> stack2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack1<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> cur <span class="token operator">=</span> stack1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>    cur<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> stack1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    cur<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> stack1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 这里为了模拟出栈。所以依次弹出，其实直接倒序一下即可</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack2<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> cur <span class="token operator">=</span> stack2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Morris-遍历"><a href="#Morris-遍历" class="headerlink" title="Morris 遍历"></a>Morris 遍历</h2><p>一种遍历二叉树的方式，并且时间复杂度 O(n),空间复杂度 O(1)<br>通过利用原树中大量空闲指针的方式，达到节省空间的目的</p><p><img src="../../images/%E4%BA%8C%E5%8F%89%E6%A0%91/morris.png" alt="&#39;&#39;"></p><h2 id="二叉树衍生"><a href="#二叉树衍生" class="headerlink" title="[二叉树衍生]"></a>[二叉树衍生]</h2><ol><li><strong>如何判断一棵树是搜索二叉树</strong></li></ol><blockquote><p>搜索二叉树的概念：任意一个子树，它的左节点比它自身小，它的右节点比它自身大</p><blockquote><p>采用 <strong>（中序遍历处理）</strong>, 如果中序遍历结果是一个升序的，那就是搜索二叉树</p></blockquote></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 临时变量，记录上一次的值</span><span class="token keyword">let</span> preValue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">isBst</span><span class="token punctuation">(</span><span class="token parameter">tree<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> isLeftBst <span class="token operator">=</span> <span class="token function">isBst</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isLeftBst<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">.</span>value <span class="token operator">&lt;=</span> preValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果当前值大于上一次的值，则把当前值赋值给上一次</span>    preValue <span class="token operator">=</span> tree<span class="token punctuation">.</span>val<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token function">isBst</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="按之字形顺序打印二叉树"><a href="#按之字形顺序打印二叉树" class="headerlink" title="按之字形顺序打印二叉树"></a><a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tqId=23454&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">按之字形顺序打印二叉树</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）<br><img src="../../images/%E4%B9%8B%E5%AD%97%E5%BD%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0.png" alt="之字形"></p><p>该图打印出来为 {[1], [3,2],[4, 5]};</p><h3 id="思路及代码"><a href="#思路及代码" class="headerlink" title="思路及代码"></a>思路及代码</h3><ol><li>之字形打印，即层级打印，只是顺序变化而已，那么很容易就想到使用 BFS 来处理</li><li>使用队列来处理，这样减少递归的使用</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * @param pRoot TreeNode类 * @return int整型二维数组 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token parameter">pRoot<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span><span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 如果树为空，直接返回空数组</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pRoot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 定义结果二维数组</span>  <span class="token keyword">const</span> res<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 创建队列</span>  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 记录当前的层数</span>  <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 记录这一层的长度</span>    <span class="token keyword">const</span> length <span class="token operator">=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// 创建临时数组，用于接收下一层的数据</span>    <span class="token keyword">const</span> temp<span class="token operator">:</span> TreeNode<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 创建一维结果数组，最后直接全量推到结果二维数组中即可</span>    <span class="token keyword">const</span> cur<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">let</span> curRoot<span class="token punctuation">;</span>      <span class="token comment">// 这里需要想清楚，由于是之字形，则奇数层的时候怎么处理以及偶数层又要怎么处理</span>      <span class="token comment">// 由于定义层级从1开始，则开始为奇数层，那么考虑到后续，偶数层变换方向</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 偶数层处理，变换方向，则头部出队</span>        curRoot <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        curRoot<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curRoot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        curRoot<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curRoot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 奇数层处理，由于偶数层是正向push加入，则之字形的时候，奇数层需要尾部出队</span>        curRoot <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        curRoot<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>curRoot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        curRoot<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>curRoot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      cur<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curRoot<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    index <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双端队列处理"><a href="#双端队列处理" class="headerlink" title="双端队列处理"></a>双端队列处理</h3><ol><li>特例处理： 当树的根节点为空，则直接返回空列表 [] ；</li><li>初始化： 打印结果空列表 res ，包含根节点的双端队列 deque ；<br>BFS 循环： 当 deque 为空时跳出；<br>新建列表 tmp ，用于临时存储当前层打印结果；</li><li>当前层打印循环： 循环次数为当前层节点数（即 deque 长度）；<br>出队： 队首元素出队，记为 node；<br>打印： 若为奇数层，将 node.val 添加至 tmp 尾部；否则，添加至 tmp 头部；<br>添加子节点： 若 node 的左（右）子节点不为空，则加入 deque ；<br>将当前层结果 tmp 转化为 list 并添加入 res ；</li><li>返回值： 返回打印结果列表 res 即可；</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">decorateRecord</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span><span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> res<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> length <span class="token operator">=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">const</span> temp<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> cur <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        temp<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      cur<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>      cur<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    index<span class="token operator">++</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>temp<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉搜索树的第-K-个节点"><a href="#二叉搜索树的第-K-个节点" class="headerlink" title="二叉搜索树的第 K 个节点"></a><a href="https://www.nowcoder.com/practice/57aa0bab91884a10b5136ca2c087f8ff?tpId=13&tqId=2305268&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉搜索树的第 K 个节点</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵结点数为 n 二叉搜索树，请找出其中的第 k 小的 TreeNode 结点值。 1.返回第 k 小的节点值即可 2.不能查找的情况，如二叉树为空，则返回-1，或者 k 大于 n 等等，也返回-1 3.保证 n 个节点的值不一样</p><h3 id="思路及代码-1"><a href="#思路及代码-1" class="headerlink" title="思路及代码"></a>思路及代码</h3><p>方案一(暴力解法)</p><ol><li>要找第 K 个最小值，很容易想到直接把树遍历，然后取出所有值，再排序一下，然后取 k-1 个值就好</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/*class TreeNode &#123; *     val: number *     left: TreeNode | null *     right: TreeNode | null *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.left = (left===undefined ? null : left) *         this.right = (right===undefined ? null : right) *     &#125; * &#125; */</span><span class="token comment">/** * @param proot TreeNode类 * @param k int整型 * @return int整型 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">KthNode</span><span class="token punctuation">(</span><span class="token parameter">proot<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> k<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>proot <span class="token operator">||</span> k <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> res<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> treeNodes<span class="token operator">:</span> TreeNode<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>proot<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>treeNodes<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> cur <span class="token operator">=</span> treeNodes<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    cur<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> treeNodes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    cur<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> treeNodes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">></span> res<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> sort <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> sort<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方案二(递归中序遍历)</p><p>根据二叉搜索树的性质，左子树的元素都小于根节点，右子树的元素都大于根节点。因此它的中序遍历（左中右）序列正好是由小到大的次序，因此我们可以尝试递归中序遍历，也就是从最小的一个节点开始，找到 k 个就是我们要找的目标。</p><ol><li>设置全局变量 count 记录遍历了多少个节点，res 记录第 k 个节点。</li><li>另写一函数进行递归中序遍历，当节点为空或者超过 k 时，结束递归，返回。</li><li>优先访问左子树，再访问根节点，访问时统计数字，等于 k 则找到。</li><li>最后访问右子树。</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/*class TreeNode &#123; *     val: number *     left: TreeNode | null *     right: TreeNode | null *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.left = (left===undefined ? null : left) *         this.right = (right===undefined ? null : right) *     &#125; * &#125; */</span><span class="token comment">/** * @param proot TreeNode类 * @param k int整型 * @return int整型 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">KthNode</span><span class="token punctuation">(</span><span class="token parameter">proot<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> k<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>proot <span class="token operator">||</span> k <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">let</span> res<span class="token punctuation">;</span>  <span class="token comment">// 定义当前的次数</span>  <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token function-variable function">midOrder</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> count <span class="token operator">></span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">midOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">===</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      res <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">midOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token function">midOrder</span><span class="token punctuation">(</span>proot<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> res<span class="token punctuation">.</span>val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=23282&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">重建二叉树</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。<br>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉树的前序遍历：根左右；中序遍历：左根右<br>由前序遍历知道根节点之后，能在中序遍历上划分出左子树和右子树。分别对中序遍历的左右子树递归进行这一过程即可建树。<br><img src="../../images/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="重建"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/*class TreeNode &#123; *     val: number *     left: TreeNode | null *     right: TreeNode | null *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.left = (left===undefined ? null : left) *         this.right = (right===undefined ? null : right) *     &#125; * &#125; */</span><span class="token comment">/** * @param preOrder int整型一维数组 * @param vinOrder int整型一维数组 * @return TreeNode类 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">reConstructBinaryTree</span><span class="token punctuation">(</span>  <span class="token parameter">preOrder<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  vinOrder<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token operator">:</span> TreeNode <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>preOrder<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>preOrder<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> rootVal <span class="token operator">=</span> preOrder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 从中序遍历结果中找到分割点</span>  <span class="token keyword">const</span> povitIndex <span class="token operator">=</span> vinOrder<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span><span class="token punctuation">;</span>  root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">reConstructBinaryTree</span><span class="token punctuation">(</span>    preOrder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> povitIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    vinOrder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> povitIndex<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">reConstructBinaryTree</span><span class="token punctuation">(</span>    preOrder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>povitIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    vinOrder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>povitIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉树的子结构"><a href="#二叉树的子结构" class="headerlink" title="二叉树的子结构"></a><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=23293&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉树的子结构</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树 A，B，判断 B 是不是 A 的子结构。（我们约定空树不是任意一个树的子结构）<br>假如给定 A 为{8,8,7,9,2,#,#,#,#,4,7}，B 为{8,9,2}，2 个树的结构如下，可以看出 B 是 A 的子结构</p><p><img src="../../images/%E5%AD%90%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0.png" alt="子结构"></p><h3 id="思路-队列"><a href="#思路-队列" class="headerlink" title="思路(队列)"></a>思路(队列)</h3><p>这道题的思路，无非就是在 A 树中遍历每个节点尝试找到那个子树，然后每次以该节点出发能不能将子树与 B 树完全匹配。能用前序遍历解决，我们也可以用层次遍历来解决。<br>首先对于 A 树层次遍历每一个节点，遇到一个与 B 树根节点相同的节点，我们就开始同步层次遍历比较以这个节点为根的树中是否出现了 B 树的全部节点。因为我们只考虑 B 树的所有节点是否在 A 树中全部出现，那我们就以 B 树为基，再进行一次层次遍历，A 树从那个节点开始跟随 B 树一致进行层次遍历就行了，比较对应的每个点是否相同，或者 B 树是否有超出 A 树没有的节点</p><ol><li>先判断空树，空树不为子结构。</li><li>利用队列辅助，层次遍历第一棵树，每次检查遍历到的节点是否和第二棵树的根节点相同。</li><li>若是相同，可以以该节点为子树根节点，再次借助队列辅助，同步层次遍历这个子树与第二棵树，这个时候以第二棵树为基，只要找到第二棵树的全部节点，就算找到了子结构。</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/*class TreeNode &#123; *     val: number *     left: TreeNode | null *     right: TreeNode | null *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.left = (left===undefined ? null : left) *         this.right = (right===undefined ? null : right) *     &#125; * &#125; */</span><span class="token comment">/** * @param pRoot1 TreeNode类 * @param pRoot2 TreeNode类 * @return bool布尔型 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">HasSubtree</span><span class="token punctuation">(</span><span class="token parameter">pRoot1<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> pRoot2<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">&#123;</span>  <span class="token comment">// B树为空，肯定不是子结构</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pRoot2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// A树为空，B树不为空，也不是子结构</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>pRoot1 <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> pRoot2 <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 检查是否是子结构的方法，队列处理</span>  <span class="token keyword">const</span> <span class="token function-variable function">checkIsSubTree</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root1<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> root2<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 创建两个队列</span>    <span class="token keyword">const</span> queue1 <span class="token operator">=</span> <span class="token punctuation">[</span>root1<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> queue2 <span class="token operator">=</span> <span class="token punctuation">[</span>root2<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 这里遍历B树，让A树队列跟随执行即可，减少循环次数</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>queue2<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> cur1 <span class="token operator">=</span> queue1<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> cur2 <span class="token operator">=</span> queue2<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// A树节点为空，或者两个节点值不等，则肯定不是子结构</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cur1 <span class="token operator">||</span> cur1<span class="token punctuation">.</span>val <span class="token operator">!==</span> cur2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 依次入队</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>cur2<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        queue1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur1<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        queue2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>cur2<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        queue1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur1<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        queue2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// 定义A树的队列</span>  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>pRoot1<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> cur <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 发现当前的值和B树的值相同，进入依次比较</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">===</span> pRoot2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 这里不能直接返回该方法结果，因为某一个节点值相同，但是子结构还在下面</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">checkIsSubTree</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> pRoot2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cur<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    cur<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="思路-递归"><a href="#思路-递归" class="headerlink" title="思路(递归)"></a>思路(递归)</h3><p>既然是要找到 A 树中是否有 B 树这样子树，如果是有子树肯定是要遍历这个子树和 B 树，将两个的节点一一比较，但是这样的子树不一定就是 A 树根节点开始的，所以我们还要先找到子树可能出现的位置。<br>既然是可能的位置，那我们可以对 A 树的每个节点前序递归遍历，寻找是否有这样的子树，而寻找是否有子树的时候，我们就将 A 树与 B 树同步前序遍历，依次比较节点值。</p><ol><li>因为空树不是任何树的子树，所以要先判断 B 树是否为空树。</li><li>当 A 树为空节点，但是 B 树还有节点的时候，不为子树，但是 A 树不为空节点，B 树为空节点时可以是子树。</li><li>每次递归比较 A 树从当前节点开始，是否与 B 树完全一致，同步前序遍历。</li><li>A 树自己再前序遍历进入子节点，当作子树起点再与 B 树同步遍历。</li><li>以上情况任意只要有一种即可。</li></ol><p><img src="../../images/%E5%AD%90%E7%BB%93%E6%9E%84%E5%9B%BE%E7%A4%BA.gif" alt="图示"></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * @param pRoot1 TreeNode类 * @param pRoot2 TreeNode类 * @return bool布尔型 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">HasSubtree</span><span class="token punctuation">(</span><span class="token parameter">pRoot1<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> pRoot2<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">&#123;</span>  <span class="token comment">// B树不存在，不是子结构</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pRoot2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>pRoot1 <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> pRoot2 <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> <span class="token function-variable function">checkIsSubTree</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root1<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> root2<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root1 <span class="token operator">&amp;&amp;</span> root2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 任一一个为空了，则说明找到底了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root1 <span class="token operator">||</span> <span class="token operator">!</span>root2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root1<span class="token punctuation">.</span>val <span class="token operator">!==</span> root2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token function">checkIsSubTree</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>      <span class="token function">checkIsSubTree</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// 前序遍历，找到其值是否相同</span>  <span class="token keyword">const</span> checkRes <span class="token operator">=</span> <span class="token function">checkIsSubTree</span><span class="token punctuation">(</span>pRoot1<span class="token punctuation">,</span> pRoot2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> flag1 <span class="token operator">=</span> <span class="token function">HasSubtree</span><span class="token punctuation">(</span>pRoot1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> pRoot2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> flag2 <span class="token operator">=</span> <span class="token function">HasSubtree</span><span class="token punctuation">(</span>pRoot1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> pRoot2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> checkRes <span class="token operator">||</span> flag1 <span class="token operator">||</span> flag2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a><a href="https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=13&tqId=1374963&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉树的镜像</a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><h3 id="思路-递归-1"><a href="#思路-递归-1" class="headerlink" title="思路 (递归)"></a>思路 (递归)</h3><p>因为我们需要将二叉树镜像，意味着每个左右子树都会交换位置，如果我们从上到下对遍历到的节点交换位置，但是它们后面的节点无法跟着他们一起被交换，因此我们可以考虑自底向上对每两个相对位置的节点交换位置，这样往上各个子树也会被交换位置。<br>自底向上的遍历方式，我们可以采用后序递归的方法。</p><ol><li>先深度最左端的节点，遇到空树返回，处理最左端的两个子节点交换位置。</li><li>然后进入右子树，继续按照先左后右再回中的方式访问。</li><li>再返回到父问题，交换父问题两个子节点的值。</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/*class TreeNode &#123; *     val: number *     left: TreeNode | null *     right: TreeNode | null *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.left = (left===undefined ? null : left) *         this.right = (right===undefined ? null : right) *     &#125; * &#125; */</span><span class="token comment">/** * @param pRoot TreeNode类 * @return TreeNode类 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">Mirror</span><span class="token punctuation">(</span><span class="token parameter">pRoot<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span><span class="token operator">:</span> TreeNode <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pRoot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">Mirror</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">Mirror</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  pRoot<span class="token punctuation">.</span>left <span class="token operator">=</span> right<span class="token punctuation">;</span>  pRoot<span class="token punctuation">.</span>right <span class="token operator">=</span> left<span class="token punctuation">;</span>  <span class="token keyword">return</span> pRoot<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="思路（栈的方式）"><a href="#思路（栈的方式）" class="headerlink" title="思路（栈的方式）"></a>思路（栈的方式）</h3><p>二叉树中能够用递归的，我们大多也可以用栈来实现。栈的访问是一种自顶向下的访问，因此我们需要在左右子节点入栈后直接交换，然后再访问后续栈中内容。</p><ol><li>优先检查空树的情况。</li><li>使用栈辅助遍历二叉树，根节点先进栈。</li><li>遍历过程中每次弹出栈中一个元素，然后该节点左右节点分别入栈。</li><li>同时我们交换入栈两个子节点的值，因为子节点已经入栈了再交换，就不怕后续没有交换。</li></ol><p><img src="../../images/%E9%95%9C%E5%83%8F%E6%A0%88%E5%A4%84%E7%90%86.gif" alt="栈处理"></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * @param pRoot TreeNode类 * @return TreeNode类 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">Mirror</span><span class="token punctuation">(</span><span class="token parameter">pRoot<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span><span class="token operator">:</span> TreeNode <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pRoot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 入栈</span>  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 出栈</span>    <span class="token keyword">const</span> cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cur<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    cur<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 这里就是交换</span>    <span class="token keyword">const</span> left <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    cur<span class="token punctuation">.</span>left <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    cur<span class="token punctuation">.</span>right <span class="token operator">=</span> left<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> pRoot<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉树中和为某一值的路径（一）"><a href="#二叉树中和为某一值的路径（一）" class="headerlink" title="二叉树中和为某一值的路径（一）"></a><a href="https://www.nowcoder.com/practice/508378c0823c423baa723ce448cbfd0c?tpId=13&tqId=634&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉树中和为某一值的路径（一）</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树 root 和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。 1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点 2.叶子节点是指没有子节点的节点 3.路径只能从父节点到子节点，不能从子节点到父节点 4.总节点数目为 n</p><h3 id="思路（递归）"><a href="#思路（递归）" class="headerlink" title="思路（递归）"></a>思路（递归）</h3><p>既然要找有没有路径的和为给定 sum 值，则只需要从根节点遍历到底节点，然后计算即可</p><ol><li>首先判断树是否为空，为空直接返回 false</li><li>然后进行 DFS 递归，每进入下一个节点，将 sum 减去当前节点值 diff 传入下去</li><li>注意几个边界，当 diff 小于 0 并且没有左右子节点，则直接返回 false,只有当 diff 为 0 并且左右子节点为空，这时候才存在该路径</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * @param root TreeNode类 * @param sum int整型 * @return bool布尔型 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">&#123;</span>  <span class="token comment">// 树为空，直接返回false</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 当到达最底层节点，并且当前sum不为0, 则该路径不是</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root <span class="token operator">&amp;&amp;</span> sum <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> notChild <span class="token operator">=</span> <span class="token operator">!</span>root<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>  <span class="token comment">// 每次减去当前层级节点值</span>  <span class="token keyword">const</span> diff <span class="token operator">=</span> sum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>  <span class="token comment">// 差值小于0，并且没有子节点，则该路径不符合</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> notChild<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 没有子节点，并且差值为0，则该路径符合</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> notChild<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 进行递归</span>  <span class="token keyword">const</span> flag <span class="token operator">=</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> diff<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> flag1 <span class="token operator">=</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> diff<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> flag <span class="token operator">||</span> flag1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="思路（栈处理）"><a href="#思路（栈处理）" class="headerlink" title="思路（栈处理）"></a>思路（栈处理）</h3><p>在二叉树中能够用递归解决的问题，很多时候我们也可以用非递归来解决。这里遍历过程也可以使用栈辅助，进行 dfs（深度优先搜索）遍历，检查往下的路径中是否有等于 sum 的路径和。<br>注意，这里仅是 dfs，而不是前序遍历，左右节点的顺序没有关系，因为每次往下都是单独添加某个节点的值相加然后继续往下，因此左右节点谁先遍历不管用。</p><ol><li>首先检查空节点，空树没有路径。</li><li>使用两个栈同步遍历，一个栈记录节点，辅助深度优先搜索，另一个栈跟随记录到该节点为止的路径和。根节点及根节点值先进栈。</li><li>遍历的时候每次弹出两个栈中的内容，判断是否是叶子节点且路径和是否等于目标值。</li><li>没有到叶子节点就将左右子节点（如果有）加入栈中，并跟随加入路径和。</li><li>如果遍历结束也没有找到路径和，则该二叉树中没有。</li></ol><p><img src="../../images/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E7%9A%84%E8%B7%AF%E5%BE%84.gif" alt="图示"></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * @param root TreeNode类 * @param sum int整型 * @return bool布尔型 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">&#123;</span>  <span class="token comment">// 树为空，返回false</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 树节点栈</span>  <span class="token keyword">const</span> rootStack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 节点和的栈，辅助记录走到当前节点的和为多少</span>  <span class="token keyword">const</span> sumStack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>rootStack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 树与和都出栈</span>    <span class="token keyword">const</span> curRoot <span class="token operator">=</span> rootStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> curSum <span class="token operator">=</span> sumStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 当和为sum,并且没有左右子几点，则路径存在</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>curRoot<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>curRoot<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> curSum <span class="token operator">===</span> sum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>curRoot<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      rootStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curRoot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>      sumStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curSum <span class="token operator">+</span> curRoot<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>curRoot<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      rootStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curRoot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>      sumStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curSum <span class="token operator">+</span> curRoot<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉树中和为某一值的路径（二）"><a href="#二叉树中和为某一值的路径（二）" class="headerlink" title="二叉树中和为某一值的路径（二）"></a><a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&tqId=23276&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉树中和为某一值的路径（二）</a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一颗二叉树的根节点 root 和一个整数 expectNumber，找出二叉树中结点值的和为 expectNumber 的所有路径。 1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点 2.叶子节点是指没有子节点的节点 3.路径只能从父节点到子节点，不能从子节点到父节点 4.总节点数目为 n</p><h3 id="思路（递归-Dfs）"><a href="#思路（递归-Dfs）" class="headerlink" title="思路（递归 Dfs）"></a>思路（递归 Dfs）</h3><p>既然是要找出所有和为 expectNumber 的路径，则需要记录每次相加和为 expectNumber 的值，<br>那么这里使用 dfs 递归查找，每次递归都传递一个 temp 数组，查找到是该路径，则加入该数组</p><ol><li>首先判断树是否为空，为空则直接返回[]</li><li>记录一个临时路径数组，并且每次递归的时候传入</li><li>每次执行到一个节点，都将节点加入 temp 数组，并且用当前 diff 减去当前节点值</li><li>如果 diff 值为 0，并且左右子节点为空，则该路径符合</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * @param root TreeNode类 * @param target int整型 * @return int整型二维数组 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">FindPath</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> target<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 树为空，返回空数组</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 创建结果数组</span>  <span class="token keyword">const</span> res<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 创建dfs方法，该方法接受三个入参，当前树，diff差值，临时路径存储数组</span>  <span class="token keyword">const</span> <span class="token function-variable function">Dfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">tree<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> diff<span class="token operator">:</span> number<span class="token punctuation">,</span> temp<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// dfs中树为空，则退出</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 是否有子节点标识</span>    <span class="token keyword">const</span> notChild <span class="token operator">=</span> <span class="token operator">!</span>tree<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    <span class="token comment">// 当前差值</span>    <span class="token keyword">const</span> curDiff <span class="token operator">=</span> diff <span class="token operator">-</span> tree<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    <span class="token comment">// 当前差值小于0，并且没有子节点，退出</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>curDiff <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> notChild<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将当前节点值，加入路径数组</span>    temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 差值为0，并且没有左右子节点，则将路径加入结果数组</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>curDiff <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> notChild<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 注意，这里使用解构，是由于js中数组传递是引用传递，这里不能直接使用引用，下面递归的时候同理</span>      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>temp<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">Dfs</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">,</span> curDiff<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">...</span>temp<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Dfs</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">,</span> curDiff<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">...</span>temp<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token function">Dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉树和为某一路径（三）"><a href="#二叉树和为某一路径（三）" class="headerlink" title="二叉树和为某一路径（三）"></a><a href="https://www.nowcoder.com/practice/965fef32cae14a17a8e86c76ffe3131f?tpId=13&tqId=2277604&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉树和为某一路径（三）</a></h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树 root 和一个整数值 sum ，求该树有多少路径的的节点值之和等于 sum 。 1.该题路径定义不需要从根节点开始，也不需要在叶子节点结束，但是一定是从父亲节点往下到孩子节点 2.总节点数目为 n 3.保证最后返回的路径个数在整形范围内</p><p><img src="../../images/%E4%B8%89.png" alt="&#39;&#39;"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>既然要找所有路径上节点和等于目标值的路径个数，那我们肯定先找这样的路径起点啊，但是我们不知道起点究竟在哪里，而且任意节点都有可能是起点，那我们就前序遍历二叉树的所有节点，每个节点都可以作为一次起点，即子树的根节点。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//以其子结点为新根</span><span class="token function">FindPath</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">FindPath</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查找路径的时候呢，也需要往下遍历，因此还可以继续前序遍历该子树，在遍历的过程遇到一个节点，sum 相应减少，若是到最后往下的一个节点值正好等于剩下的 sum，则找到一种情况。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//符合目标值</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> res<span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为前序递归的次序是根左右，因此一定是往下找的路径，不会往上回溯。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//进入子节点继续找</span><span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>每次将原树中遇到的节点作为子树的根节点送入 dfs 函数中查找有无路径，如果该节点为空则返回。</li><li>然后递归遍历这棵树每个节点，每个节点都需要这样操作。</li><li>在 dfs 函数中，也是往下递归，遇到一个节点就将 sum 减去节点值再往下。</li><li>剩余的 sum 等于当前节点值则找到一种情况。</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * @param root TreeNode类 * @param sum int整型 * @return int整型 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">FindPath</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> <span class="token function-variable function">Dfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">tree<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> diff<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">===</span> tree<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      ans<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ans <span class="token operator">+=</span> <span class="token function">Dfs</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">,</span> diff <span class="token operator">-</span> tree<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    ans <span class="token operator">+=</span> <span class="token function">Dfs</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">,</span> diff <span class="token operator">-</span> tree<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">//查询以某结点为根的路径数</span>  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token function">Dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//以其子结点为新根</span>  res <span class="token operator">+=</span> <span class="token function">FindPath</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>  res <span class="token operator">+=</span> <span class="token function">FindPath</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="判断是否是平衡二叉树"><a href="#判断是否是平衡二叉树" class="headerlink" title="判断是否是平衡二叉树"></a><a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&tqId=23250&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">判断是否是平衡二叉树</a></h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。<br>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树<br>平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>直接再求高度的同时，直接判断当前层级的高度是否大于 1 即可<br>首先这里要注意一点是 “高度差” 不是左右节点值的差值</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * @param pRoot TreeNode类 * @return bool布尔型 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">IsBalanced_Solution</span><span class="token punctuation">(</span><span class="token parameter">pRoot<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">&#123;</span>  <span class="token comment">// 空树则是平衡二叉树</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pRoot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 获取树的高度</span>  <span class="token keyword">const</span> <span class="token function-variable function">getDepth</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">getDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">getDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// 拿到层级的高度</span>  <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">getDepth</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">getDepth</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 如果高度差大于1，则不是平衡二叉树</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>left <span class="token operator">-</span> right<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 进行递归</span>  <span class="token keyword">return</span> <span class="token function">IsBalanced_Solution</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">IsBalanced_Solution</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=23451&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉树的下一个节点</a></h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的 next 指针。下图为一棵有 9 个节点的二叉树。树中从父节点指向子节点的指针用实线表示，从子节点指向父节点的用虚线表示</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>由于给定的只是树中的一个节点，那么这个节点可能是头结点，也可能不是头结点，所以第一步就是要去找到该树的头结点，然后中序遍历，并且<br>在记录中序遍历的结果，然后在中序遍历结果中找到给定的节点，再取出下一个返回即可</p><ol><li>找出树的头节点</li><li>创建一个中序结果数组，然后进行中序遍历，将中序遍历加入该结果</li><li>在中序遍历结果中，找到给定的节点</li><li>返回下一个节点即可</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/*class TreeLinkNode &#123; *     val: number *     left: TreeLinkNode | null *     right: TreeLinkNode | null *     next: TreeLinkNode | null *     constructor(val?: number, left?: TreeLinkNode | null, right?: TreeLinkNode | null, next?: TreeLinkNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.left = (left===undefined ? null : left) *         this.right = (right===undefined ? null : right) *         this.next = (next===undefined ? null : right) *     &#125; * &#125; */</span><span class="token comment">/** * @param pNode TreeLinkNode类 * @return TreeLinkNode类 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">GetNext</span><span class="token punctuation">(</span><span class="token parameter">pNode<span class="token operator">:</span> TreeLinkNode</span><span class="token punctuation">)</span><span class="token operator">:</span> TreeLinkNode <span class="token punctuation">&#123;</span>  <span class="token comment">// 定义临时指针</span>  <span class="token keyword">let</span> root <span class="token operator">=</span> pNode<span class="token punctuation">;</span>  <span class="token comment">// 创建中序遍历结果</span>  <span class="token keyword">const</span> nodes<span class="token operator">:</span> TreeLinkNode<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 找到树的头结点，如果是头结点，则next指针肯定为空</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    root <span class="token operator">=</span> root<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 中序遍历</span>  <span class="token keyword">const</span> <span class="token function-variable function">InOrder</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">tree<span class="token operator">:</span> TreeLinkNode</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">InOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    nodes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">InOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token function">InOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 在中序遍历结果中找到给定节点</span>  <span class="token keyword">const</span> index <span class="token operator">=</span> nodes<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">===</span> pNode<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 返回下一节点</span>    <span class="token keyword">return</span> nodes<span class="token punctuation">[</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a><a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tqId=23452&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">对称的二叉树</a></h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）</p><h3 id="思路（递归）-1"><a href="#思路（递归）-1" class="headerlink" title="思路（递归）"></a>思路（递归）</h3><p>判断是否是一颗对称的二叉树，即判断 左节点是否等于右支的右节点</p><ol><li>两种方向的前序遍历，同步过程中的当前两个节点，同为空，属于对称的范畴。</li><li>当前两个节点只有一个为空或者节点值不相等，已经不是对称的二叉树了。</li><li>第一个节点的左子树与第二个节点的右子树同步递归对比，第一个节点的右子树与第二个节点的左子树同步递归比较。</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * @param pRoot TreeNode类 * @return bool布尔型 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">isSymmetrical</span><span class="token punctuation">(</span><span class="token parameter">pRoot<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">&#123;</span>  <span class="token comment">// 树为空，则任务是对称的</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pRoot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> <span class="token function-variable function">Dfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">lTree<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> rTree<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 左树与右树都为空，则是对称的</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lTree <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>rTree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//只有一个为空或者节点值不同，必定不对称</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lTree <span class="token operator">||</span> <span class="token operator">!</span>rTree <span class="token operator">||</span> lTree<span class="token punctuation">.</span>val <span class="token operator">!==</span> rTree<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//每层对应的节点进入递归比较</span>    <span class="token keyword">return</span> <span class="token function">Dfs</span><span class="token punctuation">(</span>lTree<span class="token punctuation">.</span>left<span class="token punctuation">,</span> rTree<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">Dfs</span><span class="token punctuation">(</span>lTree<span class="token punctuation">.</span>right<span class="token punctuation">,</span> rTree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">Dfs</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">.</span>left<span class="token punctuation">,</span> pRoot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="思路（队列）"><a href="#思路（队列）" class="headerlink" title="思路（队列）"></a>思路（队列）</h3><p>除了递归以外，我们还可以观察，对称的二叉树每一层都是回文的情况，即两边相互对应相等，有节点值的对应节点值，没有节点的连空节点都是对应着的呢。那我们从左往右遍历一层（包括空节点），和从右往左遍历一层（包括空节点）。</p><p>这时候二叉树每一层的遍历，我就需要用到了层次遍历。层次遍历从左往右经过第一层后，怎么进入第二层？我们可以借助队列——一个先进先出的容器，在遍历第一层的时候，将第一层节点的左右节点都加入到队列中，因为加入队列的顺序是遍历的顺序且先左后右，也就导致了我从队列出来的时候也是下一层的先左后右，正好一一对应。更巧的是，如果我们要从右到左遍历一层，加入队列后也是先右后左，简直完美对应！</p><ol><li>首先判断链表是否为空，空链表直接就是对称。</li><li>准备两个队列，分别作为从左往右层次遍历和从右往左层次遍历的辅助容器，初始第一个队列加入左节点，第二个队列加入右节点。</li><li>循环中每次从队列分别取出一个节点，如果都为空，暂时可以说是对称的，进入下一轮检查；如果某一个为空或是两个节点值不同，那必定不对称。其他情况暂时对称，可以依次从左往右加入子节点到第一个队列，从右往左加入子节点到第二个队列。（这里包括空节点）</li><li>遍历结束也没有检查到不匹配，说明就是对称的。</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * @param pRoot TreeNode类 * @return bool布尔型 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">isSymmetrical</span><span class="token punctuation">(</span><span class="token parameter">pRoot<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pRoot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> leftTreeQueue <span class="token operator">=</span> <span class="token punctuation">[</span>pRoot<span class="token punctuation">.</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> rightTreeQueue <span class="token operator">=</span> <span class="token punctuation">[</span>pRoot<span class="token punctuation">.</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>leftTreeQueue<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> rightTreeQueue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//分别从左边和右边弹出节点</span>    <span class="token keyword">const</span> leftTree <span class="token operator">=</span> leftTreeQueue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> rightTree <span class="token operator">=</span> rightTreeQueue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//都为空暂时对称</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>leftTree <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>rightTree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//某一个为空或者数字不相等则不对称</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>leftTree <span class="token operator">||</span> <span class="token operator">!</span>rightTree <span class="token operator">||</span> leftTree<span class="token punctuation">.</span>val <span class="token operator">!==</span> rightTree<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//从左往右加入队列</span>    leftTreeQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>leftTree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    leftTreeQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>leftTree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//从右往左加入队列</span>    rightTreeQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>rightTree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    rightTreeQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>rightTree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="把二叉树打印成多行"><a href="#把二叉树打印成多行" class="headerlink" title="把二叉树打印成多行"></a><a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&tqId=23453&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">把二叉树打印成多行</a></h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个节点数为 n 二叉树，要求从上到下按层打印二叉树的 val 值，同一层结点从左至右输出，每一层输出一行，将输出的结果存放到一个二维数组中返回。</p><h3 id="思路（队列）-1"><a href="#思路（队列）-1" class="headerlink" title="思路（队列）"></a>思路（队列）</h3><p>这里是按层打印，所以很容易想到使用 BFS 来做处理，这里直接用队列处理</p><ol><li>创建一个队列，加入树头节点。</li><li>循环队列，每一层在该循环里面再一次加入</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * @param pRoot TreeNode类 * @return int整型二维数组 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token parameter">pRoot<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span><span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 创建结果数组</span>  <span class="token keyword">const</span> res<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pRoot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 创建树队列</span>  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> temp<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> length <span class="token operator">=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// 每层循环</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> cur <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>      cur<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>      cur<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="思路（BFS-递归）"><a href="#思路（BFS-递归）" class="headerlink" title="思路（BFS 递归）"></a>思路（BFS 递归）</h3><p>除了用队列非递归可以实现二叉树的层次遍历，我们也可以使用递归。但是递归前序遍历访问二叉树不是按照层次的顺序，但是因为“根左右”的次序，我们能保证每一层一定左边的元素先访问，后面再访问到同一层右边的元素。</p><ol><li>记录输出的二维数组初始化为空，每到一层里面填出一个一维数组。</li><li>从根节点开始，深度为 1 开始进行递归，当前节点有值递归内容才继续进行，否则返回。</li><li>如果记录输出的二维数组长度小于当前层数，说明要新到了一层，我们新开辟一个一维数组加到最后。</li><li>因为“根左右”的顺序，同一层左边必定先访问，只需要根据层数在二维数组中找到相应的行号，添加在该行末尾就一定是层次遍历的次序。</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * @param pRoot TreeNode类 * @return int整型二维数组 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token parameter">pRoot<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span><span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> res<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pRoot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> <span class="token function-variable function">Bfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> level<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 树为空，退出</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 当结果数组长度小于当前层级，则表示进入下一层了，这时候给下一层一个空数组默认值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> level<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      res<span class="token punctuation">[</span>level <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 因为层级是从1开始，所以要减一，每层加入当前树的值</span>    res<span class="token punctuation">[</span>level <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 进入下一层，层级+1</span>    <span class="token function">Bfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Bfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token function">Bfs</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="求二叉搜索树的最近公共祖先"><a href="#求二叉搜索树的最近公共祖先" class="headerlink" title="求二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree">求二叉搜索树的最近公共祖先</a></h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="../../images/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.png" alt="&#39;&#39;">;</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>若 root 是 p,q 的 最近公共祖先 ，则只可能为以下三种情况之一：</p><ol><li>p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；</li><li>p=root 且 q 在 root 的左或右子树中；</li><li>q=root 且 p 在 root 的左或右子树中；</li></ol><p><img src="../../images/%E4%BA%8C%E5%8F%89%E6%A0%91/ex.png" alt="&#39;&#39;"></p><p>本题给定了两个重要条件：<br>① 树为 二叉搜索树 ，<br>② 树的所有节点的值都是 唯一 的。<br>根据以上条件，可方便地判断 p,q 与 root 的子树关系，即：</p><ol><li>若 root.val &lt; p.val ，则 p 在 root 右子树 中；</li><li>若 root.val &gt; p.val ，则 p 在 root 左子树 中；</li><li>若 root.val = p.val ，则 p 和 root 指向 同一节点;</li></ol><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>循环搜索：</p><ol><li>当节点 root 为空时跳出；当 p,q 都在 root 的 右子树 中，则遍历至 root.right ；<br>否则，当 p,q 都在 root 的 左子树 中，则遍历至 root.left ；<br>否则，说明找到了 最近公共祖先 ，跳出；</li><li>返回值： 最近公共祖先 root ；</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>  <span class="token parameter">root<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  p<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  q<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span><span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// p、 q都在树的右边</span>      root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// p、q都在树的左边</span>      root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优化方法一"><a href="#优化方法一" class="headerlink" title="优化方法一"></a>优化方法一</h3><p>若可保证 p.val &lt; q.val ，则在循环中可减少判断条件，提升计算效率。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>  <span class="token parameter">root<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  p<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  q<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span><span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>val <span class="token operator">></span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 交换，保证p 小于q</span>    <span class="token keyword">const</span> temp <span class="token operator">=</span> p<span class="token punctuation">;</span>    q <span class="token operator">=</span> p<span class="token punctuation">;</span>    p <span class="token operator">=</span> temp<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// p、 q都在树的右边</span>      root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// p、q都在树的左边</span>      root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递推工作：<br>当 p,q 都在 root 的 右子树 中，则开启递归 root.right 并返回；否则，当 p,q 都在 root 的 左子树 中，则开启递归 root.left 并返回；返回值： 最近公共祖先 root；</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>  <span class="token parameter">root<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  p<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  q<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span><span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="寻找二叉树的最近公共祖先"><a href="#寻找二叉树的最近公共祖先" class="headerlink" title="寻找二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree">寻找二叉树的最近公共祖先</a></h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>这个与二叉搜索树的最近公共祖先类似，但是由于树不是二叉搜索树，所以无法根据值的大小做判断<br>所以如下图所示<br><img src="../../images/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E8%A7%A3%E6%9E%90.png" alt="&#39;&#39;"></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>  <span class="token parameter">root<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  p<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  q<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span><span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root <span class="token operator">||</span> root <span class="token operator">===</span> p <span class="token operator">||</span> root <span class="token operator">===</span> q<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>left<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> right<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> left<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断字符串有效括号</title>
      <link href="/2023/pan-duan-zi-fu-chuan-you-xiao-gua-hao/"/>
      <url>/2023/pan-duan-zi-fu-chuan-you-xiao-gua-hao/</url>
      
        <content type="html"><![CDATA[<h3 id="判断字符串有效括号"><a href="#判断字符串有效括号" class="headerlink" title="判断字符串有效括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">判断字符串有效括号</a></h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">isValid</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">str<span class="token operator">:</span> string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 如果字符串不是2的倍数，则肯定不是有效的</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span>length <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>     <span class="token comment">// 创建一个栈</span>  <span class="token keyword">const</span> stack<span class="token operator">:</span> string<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> cur <span class="token operator">=</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 如果是左括号，则直接入栈</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'('</span><span class="token punctuation">,</span> <span class="token string">'&#123;'</span><span class="token punctuation">,</span> <span class="token string">'['</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">inlcudes</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 如果是右括号，并且栈为空，则不是一个有效括号</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token comment">// 取出栈顶元素</span>      <span class="token keyword">const</span> top <span class="token operator">=</span> stack<span class="token punctuation">[</span>stack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// 如果匹配到了之后，就出栈</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>top <span class="token operator">===</span> <span class="token string">'('</span> <span class="token operator">&amp;&amp;</span> cur <span class="token operator">===</span> <span class="token string">')'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>top <span class="token operator">===</span> <span class="token string">'&#123;'</span> <span class="token operator">&amp;&amp;</span> cur <span class="token operator">===</span> <span class="token string">'&#125;'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>top <span class="token operator">===</span> <span class="token string">'['</span> <span class="token operator">&amp;&amp;</span> cur <span class="token operator">===</span> <span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 循环完成之后，如果栈为空，则是有效的</span>  <span class="token keyword">return</span> stack<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2023/pai-xu/"/>
      <url>/2023/pai-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><ol><li>将左侧序列看成一个有序序列，每次将一个数字插入该有序序列。插入时，从有序序列最右侧开始比较，若比较的数较大，后移一位。</li></ol><p><img src="../../images/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序">;</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> target <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>target<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">[</span>array<span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        target <span class="token operator">=</span> j<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> array<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度 O(n^2);</li><li>空间复杂度 O(1);</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="[冒泡排序]"></a>[冒泡排序]</h2><p>算法步骤:</p><blockquote><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol></blockquote><p><img src="../../images/%E6%8E%92%E5%BA%8F/bubbleSort.gif" alt="&#39;&#39;"></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="[归并排序]"></a>[归并排序]</h2><p>算法步骤:</p><blockquote><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ol></blockquote><p><img src="../../images/%E6%8E%92%E5%BA%8F/mergeSort.gif" alt="&#39;归并排序&#39;">;</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> right<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> res<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 以下两个while只会进一个，即上面循环交换剩余的数组</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>right<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    right <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token keyword">const</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> leftSortArr <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> rightSortArr <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span>leftSortArr<span class="token punctuation">,</span> rightSortArr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="归并排序衍生题"><a href="#归并排序衍生题" class="headerlink" title="归并排序衍生题"></a>归并排序衍生题</h3><p>一、<strong>小数和</strong></p><p>有这样一个数组[1,3,4,2,5],求每个数左侧小于该数的和</p><p>示例:</p><blockquote><p>[1,3,4,2,5]<br>当为 1 时，左侧无数，和为 0; 当为 3 时，左侧为 1; 当为 4 时，左侧小于是 1,3，所以和为 4;<br>最后将这些所求和再相加返回</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一、<strong>暴力法</strong></p><p>既然要求数组的小数之和，那么就每次循环，循环到某个数，再去循环该数前面的数据，如果比该数小，那么相加，最后返回结果即可，这里不做赘述</p><p>二、<strong>反向思考法(归并排序处理)</strong></p><p>转换一下思路，既然要求所有小数和，我们反转来求比该数右侧有几个比自己大的，比如： 当循环到 1 的时候，发现右边有 4 个比自己大的，那么就是有 4 个 1，循环到 3 的时候，右边有 2 个比 3 大的数，那么就有两个 3 以此类推，最后相加。这样也是一样的能求到小数和</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">getSum</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> left<span class="token operator">:</span> number<span class="token punctuation">,</span> right<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 终止条件</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">===</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span> <span class="token operator">+</span>    <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span>    <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">,</span> r</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> p1 <span class="token operator">=</span> l<span class="token punctuation">,</span>    p2 <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> m <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// r - p2 + 1 这里即是找到右侧比该数大的个数</span>    res <span class="token operator">+=</span> arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> p2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    temp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">?</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    temp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>p2 <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    temp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> temp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    arr<span class="token punctuation">[</span>l <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="[快速排序]"></a>[快速排序]</h2><p><strong>算法步骤:</strong></p><blockquote><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）随机挑选才是期望为 O(n * logn);</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序</li></ol></blockquote><p><img src="../../images/%E6%8E%92%E5%BA%8F/quickSort.gif" alt="&#39;快速排序&#39;"></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">_quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">_quickSort</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> left<span class="token operator">:</span> number<span class="token punctuation">,</span> right<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> partitionIndex <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> partitionIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> partitionIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> left<span class="token operator">:</span> number<span class="token punctuation">,</span> right<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 分区 * **/</span><span class="token keyword">function</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> left<span class="token operator">:</span> number<span class="token punctuation">,</span> right<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token operator">--</span>right<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token operator">++</span>left<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>  <span class="token keyword">return</span> left<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序衍生题"><a href="#快速排序衍生题" class="headerlink" title="快速排序衍生题"></a>快速排序衍生题</h3><p>一、<strong>荷兰国旗问题(1)</strong></p><p>有这样一个数组[4,3,5,3,7,8,1,5,7,8,2,0],再给定一个数字，请将小于等于该数字的数放在左边，大于该数字的放在右边;</p><p>示例:</p><blockquote><p>[4,3,5,3,7,8,1,5,7,9,2,0], 5<br>输出 [4,3,3,1,2,0,5,5,7,8,7,9];<br>注意： 左右两边的数可以无序</p></blockquote><p><strong>请在时间复杂度为 O(n * logN)下完成</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">_quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">_quickSort</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> left<span class="token operator">:</span> number<span class="token punctuation">,</span> right<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> part <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> part<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">_quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> left<span class="token operator">:</span> number<span class="token punctuation">,</span> right<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 这是一个处理arr[left....right]的分区函数 * 默认一arr[left]做划分 * 返回等于区域（左边界， 右边界），所以返回一个长度为2的数组 * **/</span><span class="token keyword">function</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> left<span class="token operator">:</span> number<span class="token punctuation">,</span> right<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> less <span class="token operator">=</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// &lt;区的右边界</span>  <span class="token keyword">let</span> more <span class="token operator">=</span> right<span class="token punctuation">;</span> <span class="token comment">// > 区的左边界</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// left表示当前数的位置  arr[right]表示划分值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 当前数 &lt; 划分值</span>      <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">++</span>less<span class="token punctuation">,</span> left<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 当前数 > 划分值</span>      <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">--</span>more<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      left<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> more<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">[</span>less <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> more<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="[堆排序]"></a>[堆排序]</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ol><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li></ol><p><img src="../../images/%E6%8E%92%E5%BA%8F/heapSort.gif" alt="&#39;堆排序&#39;"></p><p>堆排序中如果给定一个位置，查找父位置和子位置，如何找，</p><blockquote><p>给定位置 i，其父位置: (i - 1) / 2<br>给定位置 i, 其左孩子: 2 x i + 1<br>给定位置 i, 其右孩子: 2 x i + 2</p></blockquote><p><strong>堆排序步骤</strong></p><ol><li>创建一个堆 H[0……n-1]；</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸缩小 1，并调用 heapInsert(arr, index)，目的是把新的数组顶端数据调整到相应位置；</li><li>重复步骤 2，直到堆的尺寸为 1。</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 先构造成大顶堆</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">heapInsert</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 定义堆的大小，并且交换堆的最后一位和首位</span>  <span class="token keyword">let</span> heapSize <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> heapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>heapSize <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> heapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">--</span>heapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 这个方法的过程其实就是构造大顶堆的过程，即加入一个数，这个数需要与他那个位置的父级比较 * 如果比父级大，则两两交换，直到比倒顶部， 这是往上移动 * @param arr 数据源 * @param index 插入数据的位置 * **/</span><span class="token keyword">function</span> <span class="token function">heapInsert</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> index<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    index <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 这个方法过程就是某个数在index位置，是否可以往下移动 * @param arr 数据源 * @param index 从那个位置开始往下 * @param heapSize 堆大小 */</span><span class="token keyword">function</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> index<span class="token operator">:</span> number<span class="token punctuation">,</span> heapSize<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> left <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 左孩子下标</span>  <span class="token comment">// 下方还有孩子的时候</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> heapSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 两个孩子中谁的值更大，则把下标给largest， left + 1 表示右孩子， 即两个孩子中，谁的值大，则把下标给largest</span>    <span class="token keyword">let</span> largest <span class="token operator">=</span>      left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> heapSize <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">?</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> left<span class="token punctuation">;</span>    <span class="token comment">// 父和孩子之间谁的值更大，则把下标给largest；</span>    largest <span class="token operator">=</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">?</span> largest <span class="token operator">:</span> index<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">===</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    index <span class="token operator">=</span> largest<span class="token punctuation">;</span>    left <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> left<span class="token operator">:</span> number<span class="token punctuation">,</span> right<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> leetcode </tag>
            
            <tag> 排序 </tag>
            
            <tag> 插入排序 </tag>
            
            <tag> 冒泡排序 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表相关</title>
      <link href="/2022/lian-biao-xiang-guan/"/>
      <url>/2022/lian-biao-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h2 id="链表相关题目（以下题目均来自-leetcode）"><a href="#链表相关题目（以下题目均来自-leetcode）" class="headerlink" title="链表相关题目（以下题目均来自 leetcode）"></a>链表相关题目（以下题目均来自 leetcode）</h2><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists">合并两个有序链表</a></h3><blockquote><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br><img src="../../images/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6.jpeg" alt="示例"></p></blockquote><ul><li>思路<ol><li>针对要合并两个链表，并且还要按顺序合并，其实也不难</li><li>简单来说，就定义一个结果链表 ans，然后循环这两个链表</li><li>循环过程中，比较两个链表当前节点的值，小的就拼接到 ans 中，移动小的链表，继续循环，直到某一个链表为空</li><li>循环完成后，由于两个链表长度可能不相等，所以需要在最后将剩余的链表拼上。</li><li>还有一个注意点，由于是创建的一个新链表，而这个新链表是从 0 开始的，我们是不需要这个 0 节点的，所以最后返回 ans.next。</li></ol></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function mergeTwoLists(  list1: ListNode | null,  list2: ListNode | null): ListNode | null &#123;  const ans &#x3D; new ListNode();  let cur &#x3D; ans;  while (list1 &amp;&amp; list2) &#123;    if (list1.val &lt; list2.val) &#123;      cur.next &#x3D; list1;      list1 &#x3D; list1.next;    &#125; else &#123;      cur.next &#x3D; list2;      list2 &#x3D; list2.next;    &#125;    cur &#x3D; cur.next;  &#125;  &#x2F;&#x2F; 处理完毕之后，至多还有一个没有处理  cur.next &#x3D; list1 ? list1 : list2;  &#x2F;&#x2F; 返回next，因为ans的第一个节点为0  return ans.next;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list">反转链表</a></h3><blockquote><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p></blockquote><p><img src="../../images/fzlb.jpeg" alt="反转链表">;</p><ul><li>思路<ol><li>假设链表为 1 -&gt; 2 -&gt; 3 -&gt; null，我们想要把它改 3 -&gt; 2 -&gt; 1 -&gt; null.</li><li>在遍历链表时，将当前节点的 next 指针改为指向前一个节点。</li><li>由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。</li><li>在更改引用之前，还需要存储后一个节点。</li><li>最后返回新的头引用。</li><li>其实反转链表这是一个统一的格式，记住更好</li></ol></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * Definition for singly-linked list. * class ListNode &#123; *     val: number *     next: ListNode | null *     constructor(val?: number, next?: ListNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.next = (next===undefined ? null : next) *     &#125; * &#125; */</span><span class="token keyword">function</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token parameter">head<span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span><span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> nextNode <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>    pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>    cur <span class="token operator">=</span> nextNode<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> pre<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链表的中间节点"><a href="#链表的中间节点" class="headerlink" title="链表的中间节点"></a><a href="https://leetcode.cn/problems/middle-of-the-linked-list">链表的中间节点</a></h2><blockquote><p>给定一个头结点为 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。</p></blockquote><ul><li>思路<br>1.</li></ul><h2 id="链表的第一个公共节点"><a href="#链表的第一个公共节点" class="headerlink" title="链表的第一个公共节点"></a><a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=23257&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">链表的第一个公共节点</a></h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用两个指针 N1,N2，一个从链表 1 的头节点开始遍历，我们记为 N1，一个从链表 2 的头节点开始遍历，我们记为 N2。</p><p>让 N1 和 N2 一起遍历，当 N1 先走完链表 1 的尽头（为 null）的时候，则从链表 2 的头节点继续遍历，同样，如果 N2 先走完了链表 2 的尽头，则从链表 1 的头节点继续遍历，也就是说，N1 和 N2 都会遍历链表 1 和链表 2。</p><p>因为两个指针，同样的速度，走完同样长度（链表 1+链表 2），不管两条链表有无相同节点，都能够到达同时到达终点。</p><p>（N1 最后肯定能到达链表 2 的终点，N2 肯定能到达链表 1 的终点）。</p><p>所以，如何得到公共节点：</p><p>有公共节点的时候，N1 和 N2 必会相遇，因为长度一样嘛，速度也一定，必会走到相同的地方的，所以当两者相等的时候，则会第一个公共的节点<br>无公共节点的时候，此时 N1 和 N2 则都会走到终点，那么他们此时都是 null，所以也算是相等了。</p><p><img src="../../images/%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9.gif" alt="第一个公共节点"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/*class ListNode &#123; *     val: number *     next: ListNode | null *     constructor(val?: number, next?: ListNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.next = (next===undefined ? null : next) *     &#125; * &#125; */</span><span class="token comment">/** * @param pHead1 ListNode类 * @param pHead2 ListNode类 * @return ListNode类 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">FindFirstCommonNode</span><span class="token punctuation">(</span>  <span class="token parameter">pHead1<span class="token operator">:</span> ListNode<span class="token punctuation">,</span>  pHead2<span class="token operator">:</span> ListNode</span><span class="token punctuation">)</span><span class="token operator">:</span> ListNode <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> l1 <span class="token operator">=</span> pHead1<span class="token punctuation">,</span>    l2 <span class="token operator">=</span> pHead2<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!==</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    l1 <span class="token operator">=</span> l1 <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">?</span> pHead2 <span class="token operator">:</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    l2 <span class="token operator">=</span> l2 <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">?</span> pHead1 <span class="token operator">:</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> l1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链表中环的入口"><a href="#链表中环的入口" class="headerlink" title="链表中环的入口"></a><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=23449&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">链表中环的入口</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，返回 null。<br>输入描述：输入分为 2 段，第一段是入环前的链表部分，第二段是链表环的部分，后台将这 2 个会组装成一个有环或者无环单链表<br>返回值描述：返回链表的环的入口结点即可。而我们后台程序会打印这个节点<br>示例 1<br>输入：{1,2},{3,4,5}<br>返回值：3<br>说明：返回环形链表入口节点，我们后台会打印该环形链表入口节点，即 3</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>两种方案：</p><ul><li><p>使用字典存储链表走的节点，如果字典中第一次找到重复的值，则该值就是环的入口位置</p></li><li><p>使用快慢指针处理, 定义快慢指针 slow 和 fast 指针，slow 每走一步，fast 走两步，若是有环，则一定会在环的某个结点处相遇（slow == fast）</p></li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><h4 id="方案一-字典记录"><a href="#方案一-字典记录" class="headerlink" title="方案一(字典记录)"></a>方案一(字典记录)</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/*class ListNode &#123; *     val: number *     next: ListNode | null *     constructor(val?: number, next?: ListNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.next = (next===undefined ? null : next) *     &#125; * &#125; */</span><span class="token comment">/** * @param pHead ListNode类 * @return ListNode类 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">EntryNodeOfLoop</span><span class="token punctuation">(</span><span class="token parameter">pHead<span class="token operator">:</span> ListNode</span><span class="token punctuation">)</span><span class="token operator">:</span> ListNode <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pHead<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> listDic<span class="token operator">:</span> Record<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> ListNode<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>pHead<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>listDic<span class="token punctuation">[</span>pHead<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> pHead<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    listDic<span class="token punctuation">[</span>pHead<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">=</span> pHead<span class="token punctuation">;</span>    pHead <span class="token operator">=</span> pHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方案二（快慢指针）"><a href="#方案二（快慢指针）" class="headerlink" title="方案二（快慢指针）"></a>方案二（快慢指针）</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/*class ListNode &#123; *     val: number *     next: ListNode | null *     constructor(val?: number, next?: ListNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.next = (next===undefined ? null : next) *     &#125; * &#125; */</span><span class="token comment">/** * @param pHead ListNode类 * @return ListNode类 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">EntryNodeOfLoop</span><span class="token punctuation">(</span><span class="token parameter">pHead<span class="token operator">:</span> ListNode</span><span class="token punctuation">)</span><span class="token operator">:</span> ListNode <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pHead<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> slow <span class="token operator">=</span> pHead<span class="token punctuation">,</span>    fast <span class="token operator">=</span> pHead<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment">// 第一次相遇的节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">===</span> fast<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 这里如果快指针为null，则表明走到链表底了，那么链表就没有环</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> fast<span class="token punctuation">.</span>next <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 重新指向链表头部</span>  fast <span class="token operator">=</span> pHead<span class="token punctuation">;</span>  <span class="token comment">// 与第一次相遇的节点相同速度出发，相遇的时候就是入口节点</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!==</span> slow<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> fast<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="难度中等-删除链表中的重复节点"><a href="#难度中等-删除链表中的重复节点" class="headerlink" title="难度中等 删除链表中的重复节点"></a>难度中等 <a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=23450&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">删除链表中的重复节点</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><p>数据范围：链表长度满足 0≤n≤1000 ，链表中的值满足 1≤val≤1000</p><p>进阶：空间复杂度 O(n)，时间复杂度 O(n)</p><p>例如输入{1,2,3,3,4,4,5}时，对应的输出为{1,2,5}，对应的输入输出链表如下图所示<br><img src="../../images/%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9.png" alt="图示"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>使用 hash 表记录出现过的数据，如果有重复的,将这一项记录为 true,</li><li>然后创建一个新的链表，重新按 hash 表加入即可</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/*class ListNode &#123; *     val: number *     next: ListNode | null *     constructor(val?: number, next?: ListNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.next = (next===undefined ? null : next) *     &#125; * &#125; */</span><span class="token comment">/** * @param pHead ListNode类 * @return ListNode类 */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">deleteDuplication</span><span class="token punctuation">(</span><span class="token parameter">pHead<span class="token operator">:</span> ListNode</span><span class="token punctuation">)</span><span class="token operator">:</span> ListNode <span class="token punctuation">&#123;</span>  <span class="token comment">// 创建字典</span>  <span class="token keyword">const</span> repeatDic<span class="token operator">:</span> Record<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> boolean<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> cur <span class="token operator">=</span> pHead<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果在字典里，则将该项置为true</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>repeatDic<span class="token punctuation">,</span> cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      repeatDic<span class="token punctuation">[</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      repeatDic<span class="token punctuation">[</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">let</span> ansNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  cur <span class="token operator">=</span> pHead<span class="token punctuation">;</span>  <span class="token keyword">let</span> ans <span class="token operator">=</span> ansNode<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>repeatDic<span class="token punctuation">[</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      ans<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>      ans <span class="token operator">=</span> ans<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 这里如果不在hash表里面需要将尾节点置空，否则如果最后的数据是重复，那么无法去掉</span>      ans<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> ansNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/description/">两数相加</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><img src="../../images/%E9%93%BE%E8%A1%A8%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0.jpeg" alt="&#39;&#39;"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这里链表是逆序的，注意这个。 其次由于数字相加需要考虑进位的情况，当这两个考虑之后，就迎刃而解了</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>  <span class="token parameter">l1<span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  l2<span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span><span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 定义结果链表</span>  <span class="token keyword">const</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 这里其实是进位，懒得取名了</span>  <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> temp <span class="token operator">=</span> ans<span class="token punctuation">;</span>  <span class="token comment">// 这里会有情况，当两个链表都为空了，但是进位还有，所以这里还需判断进位是否为空</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">||</span> l2 <span class="token operator">||</span> sum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> sum1 <span class="token operator">=</span> l1<span class="token operator">?.</span>val <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> sum2 <span class="token operator">=</span> l2<span class="token operator">?.</span>val <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 当前两个链表以及进位相加</span>    <span class="token keyword">const</span> curSum <span class="token operator">=</span> sum1 <span class="token operator">+</span> sum2 <span class="token operator">+</span> sum<span class="token punctuation">;</span>    <span class="token comment">// 处理是否还有进位，预存</span>    sum <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>curSum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    temp<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>curSum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> ans<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除链表的第-N-个节点"><a href="#删除链表的第-N-个节点" class="headerlink" title="删除链表的第 N 个节点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">删除链表的第 N 个节点</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p><img src="../../images/remove_ex1.jpeg" alt="&#39;&#39;"></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>注意，这里是删除第 N 个节点，和删除第 K 个节点的题不一样的，这里只删除指定的一个节点<br>所以这里，就是先找链表长度，如果链表长度小于第 N 个，则直接返回空，因为不存在</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span><span class="token parameter">head<span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> n<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head <span class="token operator">||</span> n <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">let</span> length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    length<span class="token operator">++</span><span class="token punctuation">;</span>    cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 链表长度小于n</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  cur <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token keyword">const</span> diff <span class="token operator">=</span> length <span class="token operator">-</span> n<span class="token punctuation">;</span>  <span class="token comment">// 差值等于0，表示删除第一个节点</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> diff<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">===</span> diff <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      cur<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a><a href="https://leetcode.cn/problems/rotate-list/description/">旋转链表</a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>旋转链表，就是将链表长度 length 求出，然后把链表连成环，再旋转这个环的链表，最后在移动 length - k % length -1 个节点，再将链表在此处断开即可</p><blockquote><p>为什么是移动 length - k % length -1 个节点<br>首先 k 可能会很大，所以需要取余， 其次 如果移动的是 length - k % length 个节点，那么就多移动了一个，无法在该节点断开</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span><span class="token parameter">head<span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> k<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 处理边界条件</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head <span class="token operator">||</span> k <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">let</span> length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token comment">// 尾节点，这里需要记录一下尾节点，后续才能将链表连成环</span>  <span class="token keyword">let</span> endNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      endNode <span class="token operator">=</span> cur<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    length<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">let</span> moveCount <span class="token operator">=</span> k <span class="token operator">%</span> length<span class="token punctuation">;</span>  <span class="token comment">// 如果长度与k整除 则直接返回当前链表即可</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>moveCount <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 将链表连成环</span>  endNode<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token comment">// 开始旋转链表，转的次数是链表长度 - 次数 -1</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">-</span> moveCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 旋转之后，记录下一个节点</span>  <span class="token keyword">let</span> headNext <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token comment">// 将链表下一个节点置为null, 断开链表的环</span>  head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> headNext<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a><a href="https://leetcode.cn/problems/partition-list/description/">分隔链表</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p><p>你应当 保留 两个分区中每个节点的初始相对位置。</p><p><img src="../../images/%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8%E7%A4%BA%E4%BE%8B.jpeg" alt="示例"></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>既然要分隔链表，并且注意题目信息，所有小于 x 的值在大于等于 x 的左边，所以我们可以直接创建两个链表，将小于该 x 的放一个链表，大于等于的放另一个链表<br>最后再将两个链表连接即可</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token parameter">head<span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> x<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">let</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token comment">// 创建结果链表，即小于x的头链表</span>  <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 创建尾链表，即大于等于x的</span>  <span class="token keyword">let</span> endAns <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> tempAns <span class="token operator">=</span> ans<span class="token punctuation">,</span>    endTempAns <span class="token operator">=</span> endAns<span class="token punctuation">;</span>  <span class="token comment">// 循环</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 小于x的创建新的链表，并且将尾链表下一个节点置为空，防止尾链表后面有小于x的值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      tempAns<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>      tempAns <span class="token operator">=</span> tempAns<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      endTempAns<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 同理，大于等于的创建新链表，并且将小于x的链表尾节点指向null</span>      tempAns<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      endTempAns<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>      endTempAns <span class="token operator">=</span> endTempAns<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 重新指向首链表，找到最后一个节点</span>  tempAns <span class="token operator">=</span> ans<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>tempAns<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    tempAns <span class="token operator">=</span> tempAns<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 最后一个节点指向尾链表</span>  tempAns<span class="token punctuation">.</span>next <span class="token operator">=</span> endAns<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token keyword">return</span> ans<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="寄偶链表"><a href="#寄偶链表" class="headerlink" title="寄偶链表"></a><a href="https://leetcode.cn/problems/odd-even-linked-list">寄偶链表</a></h2><p>给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。</p><p>第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。</p><p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p><p>你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>因为是要在 O(1)的空间复杂度上解决，则不能使用暴力的创建一个新链表，然后根据奇偶性做增加了；<br>所以这里考虑使用双指针方式解决</p><blockquote><ol><li>创建奇数指针 odd 并指向 head</li><li>创建偶数指针 even 并执行 head.next</li><li>循环偶数指针，并且偶数指针跟随移动，在循环中将奇数全部放入奇数指针中，同理偶数指针中就只有偶数</li><li>最后将奇数指针的 next 指向偶数指针即可，返回 head;</li></ol></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">oddEvenList</span><span class="token punctuation">(</span><span class="token parameter">head<span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span><span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 偶数指针</span>  <span class="token keyword">let</span> even <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token comment">// 奇数指针，并且再创建一个临时偶数指针执行原有的偶数指针</span>  <span class="token keyword">let</span> odd <span class="token operator">=</span> head<span class="token punctuation">,</span>    evenNode <span class="token operator">=</span> even<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>evenNode <span class="token operator">&amp;&amp;</span> evenNode<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 计数指针指向偶数的下一个</span>    odd<span class="token punctuation">.</span>next <span class="token operator">=</span> evenNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    odd <span class="token operator">=</span> odd<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment">// 偶数指针下一个指向计数指针下一个，即偶数当前是偶数，但是下一个是奇数，所以相当于将偶数的下一个节点删除</span>    evenNode<span class="token punctuation">.</span>next <span class="token operator">=</span> odd<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    evenNode <span class="token operator">=</span> evenNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 最后奇数指针的next执行偶数指针</span>  odd<span class="token punctuation">.</span>next <span class="token operator">=</span> even<span class="token punctuation">;</span>  <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/2022/shuang-zhi-zhen/"/>
      <url>/2022/shuang-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p><code>双指针</code>，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个<code>相同方向（快慢指针）</code>或者<code>相反方向（对撞指针)</code>的指针进行扫描，从而达到相应的目的。 换言之，双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算.</p><p><a href="https://leetcode.cn/problems/is-subsequence">判断子序列-力扣 392 题</a></p><blockquote><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）.</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>针对要判断 s 是否是 t 的子序列，则需要判断 s 字符串在 t 字符串中存在或则 s 的字符组成方式需要在 t 中能找到。</li><li>针对这种，则考虑使用双指针的方式，定义指针 i 指向 s，指针 j 指向 t。</li><li>则定义当前字符 cur，针对 s[i] === t[j]的时候 i 指针向右移动，同时 j 指针向右移动，并将此时的 t[j]拼接到字符串 cur 中</li><li>最后将拼接的字符串 cur 和 s 做对比,一致则是子序列，否则不是子序列</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">isSubsequence</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token operator">:</span> string<span class="token punctuation">,</span> t<span class="token operator">:</span> string</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> cur <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      cur <span class="token operator">=</span> cur <span class="token operator">+</span> t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>      i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    j<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> cur <span class="token operator">===</span> s<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="训练计划（1）"><a href="#训练计划（1）" class="headerlink" title="训练计划（1）"></a><a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/5v8a6t/">训练计划（1）</a></h2><p>教练使用整数数组 actions 记录一系列核心肌群训练项目编号。为增强训练趣味性，需要将所有奇数编号训练项目调整至偶数编号训练项目之前。请将调整后的训练项目编号以 数组 形式返回。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>考虑定义双指针 i , j 分列数组左右两端，循环执行：</p><ol><li>指针 i 从左向右寻找偶数；</li><li>指针 j 从右向左寻找奇数；</li><li>将 偶数 nums[i] 和 奇数 nums[j] 交换。</li></ol><p>算法流程：<br>初始化： i , j 双指针，分别指向数组 nums 左右两端；<br>循环交换： 当 i=j 时跳出；</p><blockquote><p>指针 i 遇到奇数则执行 i=i+1 跳过，直到找到偶数；<br>指针 j 遇到偶数则执行 j=j−1 跳过，直到找到奇数；<br>交换 nums[i] 和 nums[j] 值；<br>返回值： 返回已修改的 nums 数组。</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">trainingPlan</span><span class="token punctuation">(</span><span class="token parameter">actions<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>actions<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    right <span class="token operator">=</span> actions<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果右侧是偶数，则跳过, 在循环内最终有可能left = right指针，所以这里要判断</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> actions<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      right<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 如果左侧是奇数，跳过</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> actions<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      left<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">[</span>actions<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> actions<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>actions<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> actions<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> actions<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><a href="https://leetcode.cn/problems/move-zeroes">移动零</a></h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。<br>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。<br>注意到以下性质：</p><blockquote><ol><li>左指针左边均为非零数；</li><li>右指针左边直到左指针处均为零。</li></ol></blockquote><p>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      left<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    right<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      j<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water">盛最多水的容器</a></h2><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。<br>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>返回容器可以储存的最大水量。</p><blockquote><p>说明：你不能倾斜容器。</p></blockquote><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>由于盛水最多，那么就需要容器底部最大，即（碗口原理）</p><p>初始化： 双指针 i, j 分列水槽左右两端；<br>循环收窄： 直至双指针相遇时跳出；<br>更新面积最大值 resresres ；<br>选定两板高度中的短板，向中间收窄一格；<br>返回值： 返回面积最大值 resresres</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">maxArea</span><span class="token punctuation">(</span><span class="token parameter">height<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    right <span class="token operator">=</span> height<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>    ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> width <span class="token operator">=</span> right <span class="token operator">-</span> left<span class="token punctuation">;</span>    <span class="token keyword">const</span> realHeight <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>width <span class="token operator">*</span> realHeight<span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 不断往两边收窄，然后比较最大值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      left<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      right<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><a href="https://leetcode.cn/problems/3sum">三数之和</a></h2><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。</p><blockquote><p>注意：答案中不可以包含重复的三元组</p></blockquote><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>首先对数组进行排序，排序后固定一个数 nums[i]，再使用左右指针指向 nums[i]后面的两端，数字分别为 nums[L] 和 nums[R]，计算三个数的和 sum 判断是否满足为 0，满足则添加进结果集<br>如果 sum 大于 0, 则将右指针减一<br>如果 sum 小于 0, 将左指针+1;</p><p>由于该处理，会把重复的加进来，所以在 sum 为 0 时直接使用 Set 去重即可；</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">threeSum</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 创建set，在加入的时候去重处理</span>    <span class="token keyword">const</span> numsSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    nums<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// 以i为基点，定义左右指针</span>        <span class="token keyword">let</span> left <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">const</span> sum <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                left <span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                right <span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// sum为0，加到set中</span>            numsSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>            left <span class="token operator">++</span><span class="token punctuation">;</span>            right <span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 这里对加入到set中的数据再还原会数组</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span>numsSet<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> item<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">as</span> unknown <span class="token keyword">as</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water">接雨水</a></h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="../../images/%E5%8F%8C%E6%8C%87%E9%92%88/rainwatertrap.png" alt="&#39;&#39;"></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>维护两个指针 left 和 right，以及两个变量 leftMax 和 rightMax 初始时 left=0,right=n−1,leftMax=0,rightMax=0,。指针 left 只会向右移动，指针 right 只会向左移动，在移动指针的过程中维护两个变量 leftMax 和 rightMax 的值。</p><p>当两个指针没有相遇时，进行如下操作：</p><p>使用 height[left] 和 height[right] 的值更新 leftMax 和 rightMax\的值；</p><p>如果 height[left] &lt; height[right]，则必有 leftMax &lt; rightMax，下标 left 处能接的雨水量等于 leftMax−height[left]，将下标 left 处能接的雨水量加到能接的雨水总量，然后将 left 加 1（即向右移动一位）；</p><p>如果 height[left] ≥ height[right]，则必有 leftMax ≥ rightMax，下标 right 处能接的雨水量等于 rightMax−height[right]，将下标 right 处能接的雨水量加到能接的雨水总量，然后将 right 减 1（即向左移动一位）</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">trap</span><span class="token punctuation">(</span><span class="token parameter">height<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">let</span> max<span class="token operator">:</span> number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> length <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    right <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> l_max <span class="token operator">=</span> height<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    r_max <span class="token operator">=</span> height<span class="token punctuation">[</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    l_max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>l_max<span class="token punctuation">,</span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    r_max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>r_max<span class="token punctuation">,</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l_max <span class="token operator">&lt;</span> r_max<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      max <span class="token operator">+=</span> l_max <span class="token operator">-</span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>      left<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      max <span class="token operator">+=</span> r_max <span class="token operator">-</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>      right<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> max<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters">无重复字符的最长子串</a></h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>如下:<br>输入: s = “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p><blockquote><p>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>一、双指针</p><p>定义指针 i 和 j，j 的初始值是 i + 1，以 i 为基准，让 j 往后循环，并且将 j 的字符拼到临时字符上<br>之后记录字符长度和结果长度，两者取最大值<br>返回结果即可</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token operator">:</span> string</span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> resStr <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>      j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>resStr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      resStr <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>resStr<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>      j<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> resStr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二、滑动窗口</p><p>滑动窗口其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！</p><p>只要把队列的左边的元素移出就行了，直到满足题目要求！</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token operator">:</span> string</span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">let</span> strArr<span class="token operator">:</span> string<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> max<span class="token operator">:</span> number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> cur <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> index <span class="token operator">=</span> strArr<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">===</span> cur<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      strArr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    strArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>    max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> strArr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> max<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="找到字符串中所有字符的异位词"><a href="#找到字符串中所有字符的异位词" class="headerlink" title="找到字符串中所有字符的异位词"></a><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string">找到字符串中所有字符的异位词</a></h2><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>方法一: 窗口暴力法</p><ol><li>先将 p 字符排序</li><li>循环字符 s,往窗口中加入字符，当窗口长度与 p 相同，排序窗口并比较，如果一直，则将索引加入结果</li><li>返回结果</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">findAnagrams</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token operator">:</span> string<span class="token punctuation">,</span> p<span class="token operator">:</span> string</span><span class="token punctuation">)</span><span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s <span class="token operator">||</span> s<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 排序p字符</span>  <span class="token keyword">const</span> sortStr <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> cur <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 如果当前字符不在p中，直接往下</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sortStr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">const</span> temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> curIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token comment">// 往窗口加入字符</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>      temp<span class="token punctuation">.</span>length <span class="token operator">!==</span> p<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span>      s<span class="token punctuation">[</span>curIndex<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span>      sortStr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>curIndex<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>curIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      curIndex<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">const</span> target <span class="token operator">=</span> temp<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 相等则加入索引</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">===</span> sortStr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      ans<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是会发现，其实字符被多次比较了，所以当字符很大时，会超时</p><p>方法二: 滑动窗口 + 哈希表</p><p>可以先统计出字符串 p 中每个字符的词频数，再把 p 的长度作为滑动窗口的宽度，把这个窗口在字符串 s 中移动，统计窗口中的词频数，如果在移动的过程中，窗口中的词频数与 p 的词频数相等，那么，这个窗口就是 p 的一个异位词。</p><p><img src="../../images/%E5%8F%8C%E6%8C%87%E9%92%88/1638063958-WzvElV-file_1638063958629.png" alt="&#39;&#39;"></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum">滑动窗口的最大值</a></h2><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回 滑动窗口中的最大值 。</p><p><img src="../../images/%E5%8F%8C%E6%8C%87%E9%92%88/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.png" alt="&#39;示例&#39;"></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nums<span class="token punctuation">.</span>length <span class="token operator">||</span> k <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 双端队列，内部存储索引,并且要保持队列中数据是单调递减的</span>  <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// i 表示窗口的右边界</span>    <span class="token comment">// 循环表示队列中最后一个数的下标是否大于nums[i]的值，如果不大于，则将队列中该值删掉</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>queue<span class="token punctuation">[</span>queue<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// i - k的下标过期，即窗口左值往右移动</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> i <span class="token operator">-</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 窗口构建完成</span>      ans<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      index<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2022/shu-zu/"/>
      <url>/2022/shu-zu/</url>
      
        <content type="html"><![CDATA[<h2 id="数组相关-以下所有练习题均来自于leetcode"><a href="#数组相关-以下所有练习题均来自于leetcode" class="headerlink" title="数组相关(以下所有练习题均来自于leetcode)"></a>数组相关(以下所有练习题均来自于leetcode)</h2><blockquote><p><a href="https://leetcode.cn/problems/running-sum-of-1d-array">给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。请返回 nums 的动态和。</a></p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; 方法一function runningSum(nums: number[]): number[] &#123;    const sum: number[] &#x3D; [];    while(nums.length)&#123;        const cur &#x3D; nums.shift();        const pre &#x3D; sum[sum.length - 1] || 0;        sum.push(cur + pre);    &#125;    return sum;&#125;;&#x2F;&#x2F; 方法二function runningSum(nums: number[]): number[] &#123;  nums.reduce((pre, next, index) &#x3D;&gt; &#123;        nums[index] &#x3D; pre + next;        return nums[index];  &#125;);  return nums;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><a href="https://leetcode.cn/problems/find-pivot-index">给你一个整数数组 nums ，请计算数组的 中心下标 。数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。</a></p></blockquote><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><ol><li>题目要求的是左右两边的和相等的时候，即为中心下标。</li><li>那么怎么去计算左右两边的值呢?</li><li>其实可以这样，先去求所有元素的总和，然后定义左边的和为leftSum</li><li>之后循环这个数组，每次循环，用总和减去当前的值，这时候的总和即为右边的和，再判断是否相等，相等则返回当前的索引</li><li>不相等则表示不是中心下标，leftSum + 当前值，继续循环，如果循环完成都没找到，则不存在中心下标</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">pivotIndex</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> sum <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">acc<span class="token punctuation">,</span> cur</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> acc <span class="token operator">+</span> cur<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> leftSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        sum <span class="token operator">=</span> sum <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftSum <span class="token operator">===</span> sum<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        leftSum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><a href="https://leetcode.cn/problems/move-zeroes">给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。请注意 ，必须在不复制数组的情况下原地对数组进行操作。</a></p></blockquote><h3 id="解决思路-1"><a href="#解决思路-1" class="headerlink" title="解决思路"></a>解决思路</h3><ol><li>使用双指针,指针都从左边开始，每次让左指针+1,然后判断当前的值是否为0</li><li>如果不为0,则将右指针+1，并将当前值赋给右指针指代的位置。</li><li>这样的话，当值为0时，左指针机会不停+1，直到找到不为0的元素，然后执行替换</li></ol><p> <img src="../../images/%E6%8C%87%E9%92%88.gif" alt="执行动图">;</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">const</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分法</title>
      <link href="/2022/er-fen-fa/"/>
      <url>/2022/er-fen-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>对于区间[a，b]上<code>连续不断</code>且f（a）·f（b）&lt;0的函数y=f（x），通过不断地把函数f（x）的零点所在的区间一分为二，使区间的两个端点逐步逼近零点，进而得到零点近似值的方法叫<code>二分法（dichotomy）</code>, 其时间复杂度为<code>O(log(n))</code>.</p><h2 id="练习题-leetcode原题"><a href="#练习题-leetcode原题" class="headerlink" title="练习题(leetcode原题)"></a>练习题(leetcode原题)</h2><ol><li>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数</li></ol><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">var</span> <span class="token function-variable function">solution</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">isBadVersion<span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">const</span> mid <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isBadVersion</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> left<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1</li></ol><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">===</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</li></ol><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> mid <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">===</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> left<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="两数之和-II-输入有序数组"><a href="#两数之和-II-输入有序数组" class="headerlink" title="两数之和 II - 输入有序数组"></a><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted">两数之和 II - 输入有序数组</a></h2><blockquote><p>给你一个下标从 1 开始的整数数组 numbers ，该数组已按 <code>非递减顺序排列</code>  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;= index1 &lt; index2 &lt;= numbers.length 。以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 <code>重复使用相同的元素</code>。你所设计的解决方案必须只使用<code>常量级的额外空间</code>。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>首先审题，数组是 <code>非递减顺序排列</code>, 则判断可以使用<code>二分法</code>.</li><li>其次 不可以 <code>重复使用相同的元素</code>, 则表示同一个元素不能使用两次.并且 只使用<code>常量级的额外空间</code>。</li><li>还要记住一点, 数组的下标是从 1 开始的，那么我们在返回的时候，需要将返回的索引都+1, 并且index2 &gt; index1.</li><li>那么限制条件清楚了，这时候就是编码思路了。</li><li>既然要使用二分法，那么我们就需要一个基准，而这个基准是什么呢，其实不是我们的目标元素，为什么呢？ 因为如果找目标元素，那么就不是找和为target的元素了。</li><li>所以，这里首先我们对原数组循环，去找目标元素与当前值的差值，找到差值之后，再使用这个差值去二分查找在数组中的位置。</li><li>编码如下</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token parameter">numbers<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numbers<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// 找目标元素与当前值的差值</span>        <span class="token keyword">const</span> diff <span class="token operator">=</span> target <span class="token operator">-</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> left <span class="token operator">=</span> i<span class="token punctuation">,</span> right <span class="token operator">=</span> numbers<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">const</span> mid <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 这里mid > i 是要保证 index2 > index1</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">===</span> diff <span class="token operator">&amp;&amp;</span> mid <span class="token operator">></span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">// 这里是数组元素的下标从1开始，所以返回值里面需要对索引都+1</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> diff<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsonParse转换数字的坑</title>
      <link href="/2022/jsonparse-zhuan-huan-shu-zi/"/>
      <url>/2022/jsonparse-zhuan-huan-shu-zi/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近在做一个需求的时候，需要是用JSON.parse方法解析字符串。<br>本想着是一个so easy的问题, 随手写下const xx = JSON.parse(xx); 大功告成，谁知道，在验证的时候却发现转出来的数据不正确。。。。由于数据中有id等字段，而这id在后台是一个bigInterger类型，是一个长整数，而JS对于这种长整数，在数字大于了 9007199254740992 这个数就可能会丢失精度.</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然对于数字会有丢失精度的问题，那么如果把数字转为字符串不就解决了吗？大方向这样没错, 但是这里又会有一个问题，你拿到的数据就是一个字符串了，那还怎么转呢。并且都是字符串，那么你又怎么知道那些字段需要转，那些不转呢？</p><p>我的解决方案是：</p><ol><li>首先，通过JSON.parse转换，这时候数字肯定丢失精度了。</li><li>然后，将转换出来的数据拿去递归，将数字大于9007199254740992的拿出来组装成一个字段。</li><li>接下来字典拿到之后，对源字符串进行字符串的替换操作，并且找到原字符串的值增加引号</li><li>拿到替换完成的字符串，再去JSON转换。</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const getRealJsonData &#x3D; (baseStr: string) &#x3D;&gt; &#123;    if (!baseStr || typeof baseStr !&#x3D;&#x3D; &#39;string&#39;) return;    let jsonData &#x3D; null;    try &#123;      jsonData &#x3D; JSON.parse(baseStr);    &#125; catch (err) &#123;      return null;    &#125;    const needReplaceStrs: any[] &#x3D; [];    loopFindArrOrObj(jsonData, needReplaceStrs);    needReplaceStrs.forEach(function (replaceInfo) &#123;      var matchArr &#x3D; baseStr.match(eval(&#39;&#x2F;&quot;&#39; + replaceInfo.key + &#39;&quot;:[0-9]&#123;15,&#125;&#x2F;&#39;));      if (matchArr) &#123;        var str &#x3D; matchArr[0];        var replaceStr &#x3D; str.replace(&#39;&quot;&#39; + replaceInfo.key + &#39;&quot;:&#39;, &#39;&quot;&#39; + replaceInfo.key + &#39;&quot;:&quot;&#39;);        replaceStr +&#x3D; &#39;&quot;&#39;;        baseStr &#x3D; baseStr.replace(str, replaceStr);      &#125;    &#125;);    var returnJson &#x3D; null;    try &#123;      returnJson &#x3D; JSON.parse(baseStr);    &#125; catch (err) &#123;      return null;    &#125;    return returnJson;  &#125;;  &#x2F;&#x2F;遍历对象类型的  const getNeedRpStrByObj &#x3D; (obj: any, needReplaceStrs: any[]) &#x3D;&gt; &#123;    for (var key in obj) &#123;      var value &#x3D; obj[key];      if (typeof value &#x3D;&#x3D;&#x3D; &#39;number&#39; &amp;&amp; Math.abs(value) &gt; 9007199254740992) &#123;        needReplaceStrs.push(&#123; key: key &#125;);      &#125;      loopFindArrOrObj(value, needReplaceStrs);    &#125;  &#125;;  &#x2F;&#x2F;遍历数组类型的  const getNeedRpStrByArr &#x3D; (arr: string[], needReplaceStrs: any[]) &#x3D;&gt; &#123;    for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;      var value &#x3D; arr[i];      loopFindArrOrObj(value, needReplaceStrs);    &#125;  &#125;;  &#x2F;&#x2F;递归遍历  const loopFindArrOrObj &#x3D; (value: any, needRpStrArr: any[]) &#x3D;&gt; &#123;    var valueTypeof &#x3D; Object.prototype.toString.call(value);    if (valueTypeof &#x3D;&#x3D;&#x3D; &#39;[object Object]&#39;) &#123;      needRpStrArr.concat(getNeedRpStrByObj(value, needRpStrArr));    &#125;    if (valueTypeof &#x3D;&#x3D;&#x3D; &#39;[object Array]&#39;) &#123;      needRpStrArr.concat(getNeedRpStrByArr(value, needRpStrArr));    &#125;  &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> base </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双向链表</title>
      <link href="/2021/shuang-xiang-lian-biao/"/>
      <url>/2021/shuang-xiang-lian-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><ul><li>双向链表即是将单向链表的每个节点中，再设置一个指向其前驱节点的指针域。</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">Head <span class="token operator">-</span><span class="token operator">></span> Node1 <span class="token operator">-</span><span class="token operator">></span> Node2Node2 <span class="token operator">-</span><span class="token operator">></span> Node1 <span class="token operator">-</span><span class="token operator">></span> Head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="双向链表的基本方法"><a href="#双向链表的基本方法" class="headerlink" title="双向链表的基本方法"></a>双向链表的基本方法</h2><ul><li>append(element)  向链表尾部添加一个新的项。</li><li>insert(position, element)向链表的特定位置插入一个新的项。</li><li>getNode(position)获取对应位置的元素。</li><li>indexOf(element)返回元素在链表中的索引。如果链表中没有该元素就返回-1。</li><li>update(position, element)修改某个位置的元素。</li><li>removeAt(position)从链表的特定位置移除一项。</li><li>remove(element)从链表中移除一项。</li><li>isEmpty()如果链表中不包含任何元素，返回 trun，如果链表长度大于 0 则返回 false。</li><li>size()返回链表包含的元素个数，与数组的 length 属性类似。</li><li>toString()由于链表项使用了 LinkedList 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值。</li></ul><h2 id="双向链表的实现"><a href="#双向链表的实现" class="headerlink" title="双向链表的实现"></a>双向链表的实现</h2><blockquote><p>双向链表不是环装链表，则双向链表有一个重要特点，头结点的前驱为 null，尾结点的后继为 null, 即 head.prev = null, endNode.next = null<br><strong>双向链表插入的时候尤其注意链表链接的顺序，千万不能错</strong><br><img src="../../images/linkedList.png" alt="双向链表插入图片"></p></blockquote><h2 id="双向链表实现"><a href="#双向链表实现" class="headerlink" title="双向链表实现"></a>双向链表实现</h2><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">LinkedList</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">append</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      newNode<span class="token punctuation">.</span>prev <span class="token operator">=</span> currentNode<span class="token punctuation">;</span>      currentNode<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> newNode<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">insert</span><span class="token punctuation">(</span><span class="token parameter">position<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> position <span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>      <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> position<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        index<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 注意，顺序不能颠倒</span>      newNode<span class="token punctuation">.</span>prev <span class="token operator">=</span> currentNode<span class="token punctuation">;</span>      newNode<span class="token punctuation">.</span>next <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      current<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>      currentNode<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> newNode<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">remove</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>data <span class="token operator">!==</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    currentNode<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    currentNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> currentNode<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token parameter">position</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> position <span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>data<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">===</span> position<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> currentNode<span class="token punctuation">.</span>data<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">removeAt</span><span class="token punctuation">(</span><span class="token parameter">position</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> position <span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getNode</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span> <span class="token operator">!==</span> currentNode<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    currentNode<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    currentNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> currentNode<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>data <span class="token operator">===</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> index<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      index<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 枚举处理器之 enum-loader</title>
      <link href="/2021/enum-loader/"/>
      <url>/2021/enum-loader/</url>
      
        <content type="html"><![CDATA[<p><code>enum-loader</code>枚举处理器,旨在将前端定义的枚举在编译阶段自动为定义枚举添加静态方法<code>toArray</code>和<code>toDictionary</code>,方便一次定义枚举,即可将枚举自动转换为数组和字典,减少代码量,提升开发效率。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>在<code>React</code>中使用<code>TypeScript</code>,是否经常遇到自己定义了一个枚举,但是在业务开发中,经常又需要将自己定义的枚举拿去作为<code>antd</code>的<code>Select</code>组件中的数据源,那么自己又需要去定义一个和之前的枚举相关的<code>&#123; value: xx, label: xx &#125;</code>格式的数组,每次都这样操作，是否很繁琐？</li><li>那么为了解决这样的繁琐,<code>enum-loader</code>诞生了。<blockquote><p><code>enum-loader</code>是借鉴强类型语言<code>java</code>,<code>C#</code>等等的枚举处理反射机制获取单个枚举的描述信息的思想。</p></blockquote></li></ul><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>你需要先下载<code>enum-loader</code></p><pre class="line-numbers language-console" data-language="console"><code class="language-console">npm install --save-dev enum-loader 或 yarn add --save-dev enum-loader<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><strong>webpack.config.js</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  module<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    rules<span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span>        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(ts|tsx)$</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">,</span>        use<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'enum-loader'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在-umi3-项目中"><a href="#在-umi3-项目中" class="headerlink" title="在 umi3 项目中"></a>在 umi3 项目中</h2><p><strong>.umirc.ts</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">chainWebpack</span><span class="token punctuation">(</span><span class="token parameter">config<span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    config<span class="token punctuation">.</span>module    <span class="token punctuation">.</span><span class="token function">rule</span><span class="token punctuation">(</span><span class="token string">'enum-loader'</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">.(ts|tsx)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">pre</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span>include<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">[</span>      path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">cwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'src'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">cwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'config'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">'enum-loader'</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">loader</span><span class="token punctuation">(</span>require<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'enum-loader'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p><code>enum-loader</code> 会将在 typescript 中加了@name 和@description 注解的枚举进行<code>反射</code>处理，并向该枚举添加<code>toArray</code>和<code>toDictionary</code>静态方法。</p><h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h3><p>将添加了注解@name 和 @description 的枚举转换为数组，数组格式为<code>&#123;label: string, value: string&#125;[]</code>,其中<code>label</code>属性使用的是注解<code>@description</code>的值，<code>value</code>属性使用的是枚举的 <code>值</code>.</p><h3 id="toDictionary"><a href="#toDictionary" class="headerlink" title="toDictionary"></a>toDictionary</h3><p>将添加了注解@name 和 @description 的枚举转换为数组，数组格式为<code>&#123;[key: string]: &#123;label: string, value: string&#125;&#125;</code>,以枚举的<code>值</code>为 key，字典的值为 toArray 方法的{label: string, value: string}.</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>定义枚举</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">enum</span> <span class="token constant">ENUM_TEST</span> <span class="token punctuation">&#123;</span>  <span class="token comment">/**   * @name TEST   * @description 测试  */</span> <span class="token constant">TEST</span> <span class="token operator">=</span> <span class="token string">'TEST'</span><span class="token punctuation">,</span> <span class="token comment">/**  * @name STATUS  * @description 状态  */</span> <span class="token constant">STATUS</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token comment">/**  * @name ALL  * @description 全部  */</span> <span class="token constant">ALL</span> <span class="token operator">=</span> <span class="token string">'ALL'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过<code>enum-loader</code>处理之后，</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 调用枚举的toArray方法，目前需要忽略tslint的检测</span><span class="token comment">// @ts-ignore</span><span class="token constant">ENUM_TEST</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出</span><span class="token punctuation">[</span>  <span class="token punctuation">&#123;</span>    <span class="token string">"label"</span><span class="token operator">:</span> <span class="token string">"测试"</span><span class="token punctuation">,</span>    <span class="token string">"value"</span><span class="token operator">:</span> <span class="token string">"TEST"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>    <span class="token string">"label"</span><span class="token operator">:</span> <span class="token string">"状态"</span><span class="token punctuation">,</span>    <span class="token string">"value"</span><span class="token operator">:</span> <span class="token string">"1"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>    <span class="token string">"label"</span><span class="token operator">:</span> <span class="token string">"全部"</span><span class="token punctuation">,</span>    <span class="token string">"value"</span><span class="token operator">:</span> <span class="token string">"ALL"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token comment">//@ts-ignore</span><span class="token constant">ENUM_TEST</span><span class="token punctuation">.</span><span class="token function">toDictionary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出</span><span class="token punctuation">&#123;</span>  <span class="token number">1</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>label<span class="token operator">:</span> <span class="token string">"状态"</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">&#125;</span>  <span class="token constant">ALL</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>label<span class="token operator">:</span> <span class="token string">"全部"</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">"ALL"</span><span class="token punctuation">&#125;</span>  <span class="token constant">TEST</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>label<span class="token operator">:</span> <span class="token string">"测试"</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">"TEST"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>PS:目前需要在调用这两个静态方法时,需要忽略ts-lint的检测,暂时还未处理枚举显示调用这两个静态方法。</p></blockquote><p><a href="https://www.npmjs.com/package/enum-loader">enum-loader</a></p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> webpack </tag>
            
            <tag> loader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单向链表</title>
      <link href="/2021/dan-xiang-lian-biao/"/>
      <url>/2021/dan-xiang-lian-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构与算法之链表"><a href="#数据结构与算法之链表" class="headerlink" title="数据结构与算法之链表"></a>数据结构与算法之链表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>存储多个元素，另外一个选择就是使用链表。</li><li>不同于数组，链表中的元素在内存中不必是连续的空间。</li><li>链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(有些语言称为指针)组成。</li></ul><h3 id="链表优点"><a href="#链表优点" class="headerlink" title="链表优点"></a>链表优点</h3><ul><li>内存空间不必是连续的，可以充分利用计算机的内存，实现灵活的内存动态管理。</li><li>链表不必在创建时就确定大小，并且大小可以无限延伸下去。</li><li>链表在插入和删除数据时，时间复杂度可以达到 O(1)，相对数组效率高很多。</li></ul><h3 id="链表缺点"><a href="#链表缺点" class="headerlink" title="链表缺点"></a>链表缺点</h3><ul><li>访问任何一个位置的元素时，需要从头开始访问。(无法跳过第一个元素访问任何一个元素)</li><li>无法通过下标值直接访问元素，需要从头开始一个个访问，直到找到对应的元素。</li><li>虽然可以轻松地到达下一个节点，但是回到前一个节点是很难的</li></ul><h3 id="链表的常见操作"><a href="#链表的常见操作" class="headerlink" title="链表的常见操作"></a>链表的常见操作</h3><ul><li>append(element)  向链表尾部添加一个新的项。</li><li>insert(position, element)向链表的特定位置插入一个新的项。</li><li>getNode(position)获取对应位置的元素。</li><li>indexOf(element)返回元素在链表中的索引。如果链表中没有该元素就返回-1。</li><li>update(position, element)修改某个位置的元素。</li><li>removeAt(position)从链表的特定位置移除一项。</li><li>remove(element)从链表中移除一项。</li><li>isEmpty()如果链表中不包含任何元素，返回 trun，如果链表长度大于 0 则返回 false。</li><li>size()返回链表包含的元素个数，与数组的 length 属性类似。</li><li>toString()由于链表项使用了 LinkedList 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值。</li></ul><h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">LinkedList</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 往链表末尾追加</span>  <span class="token function">append</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>      <span class="token comment">// 从第一个节点循环，直到最后一个节点，并将最后一个节点赋值给currentNode</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>next <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 最后节点的指针指向新创建的node</span>      currentNode<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">remove</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>data <span class="token operator">!==</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> delNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    currentNode<span class="token punctuation">.</span>next <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> delNode<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token parameter">index</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>data<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">===</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">return</span> currentNode<span class="token punctuation">.</span>data<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">removeAt</span><span class="token punctuation">(</span><span class="token parameter">index</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      currentNode<span class="token punctuation">.</span>next <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">const</span> findDelNodeData <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getNode</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>findDelNodeData<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>findDelNodeData <span class="token operator">!==</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> delNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    currentNode<span class="token punctuation">.</span>next <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> delNode<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>data <span class="token operator">===</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> index<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      index<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">insert</span><span class="token punctuation">(</span><span class="token parameter">position<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> position <span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">const</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      newNode<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>      <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>index<span class="token operator">++</span> <span class="token operator">&lt;</span> position<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      newNode<span class="token punctuation">.</span>next <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      currentNode<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> newNode<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>若有问题，可到<a href="https://github.com/CrownNight/CrownNight.github.io">github</a>中的issue评论</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础</title>
      <link href="/2021/eventloop/"/>
      <url>/2021/eventloop/</url>
      
        <content type="html"><![CDATA[<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3>]]></content>
      
      
      <categories>
          
          <category> base </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

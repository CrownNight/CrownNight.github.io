<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="二叉树相关, CrownNight的个人博客">
    <meta name="description" content="记录平时开发和学习中遇到的点点滴滴">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>二叉树相关 | CrownNight的个人博客</title>
    <link rel="icon" type="image/png" href="/medias/logo.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">CrownNight的个人博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle-o" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">CrownNight的个人博客</div>
        <div class="logo-desc">
            
            记录平时开发和学习中遇到的点点滴滴
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle-o"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/23.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">二叉树相关</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JavaScript/">
                                <span class="chip bg-color">JavaScript</span>
                            </a>
                        
                            <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">
                                <span class="chip bg-color">二叉树</span>
                            </a>
                        
                            <a href="/tags/%E6%A0%91/">
                                <span class="chip bg-color">树</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="post-category">
                                数据结构与算法
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-08-14
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    9.4k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>定义树结构为:</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">&#123;</span>
  val<span class="token operator">:</span> number<span class="token punctuation">;</span>
  left<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  right<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">val<span class="token operator">?</span><span class="token operator">:</span> number<span class="token punctuation">,</span> left<span class="token operator">?</span><span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> right<span class="token operator">?</span><span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> val<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> left<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> right<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以下将会直接使用该树结构</p>
<h2 id="二叉树的顺序打印及迭代实现"><a href="#二叉树的顺序打印及迭代实现" class="headerlink" title="[二叉树的顺序打印及迭代实现]"></a>[二叉树的顺序打印及迭代实现]</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>前序遍历的最终结果是 <strong>根-&gt;左-&gt;右</strong> 的顺序</p>
<p>一、<strong>递归实现</strong></p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">preOrder</span><span class="token punctuation">(</span><span class="token parameter">tree<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">preOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">preOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>二、<strong>非递归实现</strong></p>
<p>非递归的实现采用栈的方式，即入栈之后出栈<br>流程是： 弹出栈顶，打印，之后按照 右子节点入栈，左子节点入栈的顺序再入栈，重复流程即可</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">preOrder</span><span class="token punctuation">(</span><span class="token parameter">tree<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span>tree<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cur<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cur<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="‘中序遍历’"><a href="#‘中序遍历’" class="headerlink" title="[‘中序遍历’]"></a>[‘中序遍历’]</h3><p>中序遍历的结果是<strong>左-&gt;根-&gt;右</strong>的顺序</p>
<p>一、<strong>递归实现</strong></p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token parameter">tree<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token function">inOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">inOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>二、<strong>栈实现</strong></p>
<p>中序遍历的栈实现稍微复杂一点，这里的流程是<br>现在当前节点的所有左子节点入栈，入栈完成之后，再一次弹出打印，如果又有左子节点，则继续入栈<br>这里也有一个额外思路，就是树的右子节点也可以看成是他的左子结点，即右子节点就是自己的左子结点</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token parameter">tree<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">||</span> tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
      tree <span class="token operator">=</span> tree<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
      tree <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 出栈就打印，这时候打印的就是中序遍历</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
      tree <span class="token operator">=</span> tree<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="后续遍历"><a href="#后续遍历" class="headerlink" title="[后续遍历]"></a>[后续遍历]</h3><p>后续遍历的结果：<strong>左-&gt;右-&gt;根</strong></p>
<p>一、<strong>递归实现</strong></p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">posOrder</span><span class="token punctuation">(</span><span class="token parameter">tree<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token function">posOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">posOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>二、<strong>栈实现</strong></p>
<p>使用栈的方式处理后续遍历，需要增加一个辅助栈，即两个栈处理，<br>栈 1 stack1 先左后右的方式入栈，在栈 1 弹出的时候，将弹出树加入栈 2 中，最后打印栈 2 的出栈顺序即可</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">posOrder</span><span class="token punctuation">(</span><span class="token parameter">tree<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> stack1 <span class="token operator">=</span> <span class="token punctuation">[</span>tree<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> stack2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack1<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> cur <span class="token operator">=</span> stack1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cur<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> stack1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cur<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> stack1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 这里为了模拟出栈。所以依次弹出，其实直接倒序一下即可</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack2<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> cur <span class="token operator">=</span> stack2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Morris-遍历"><a href="#Morris-遍历" class="headerlink" title="Morris 遍历"></a>Morris 遍历</h2><p>一种遍历二叉树的方式，并且时间复杂度 O(n),空间复杂度 O(1)<br>通过利用原树中大量空闲指针的方式，达到节省空间的目的</p>
<p><img src="../../images/%E4%BA%8C%E5%8F%89%E6%A0%91/morris.png" alt="&#39;&#39;"></p>
<h2 id="二叉树衍生"><a href="#二叉树衍生" class="headerlink" title="[二叉树衍生]"></a>[二叉树衍生]</h2><ol>
<li><strong>如何判断一棵树是搜索二叉树</strong></li>
</ol>
<blockquote>
<p>搜索二叉树的概念：任意一个子树，它的左节点比它自身小，它的右节点比它自身大</p>
<blockquote>
<p>采用 <strong>（中序遍历处理）</strong>, 如果中序遍历结果是一个升序的，那就是搜索二叉树</p>
</blockquote>
</blockquote>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 临时变量，记录上一次的值</span>
<span class="token keyword">let</span> preValue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">isBst</span><span class="token punctuation">(</span><span class="token parameter">tree<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> isLeftBst <span class="token operator">=</span> <span class="token function">isBst</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isLeftBst<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">.</span>value <span class="token operator">&lt;=</span> preValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 如果当前值大于上一次的值，则把当前值赋值给上一次</span>
    preValue <span class="token operator">=</span> tree<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> <span class="token function">isBst</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="按之字形顺序打印二叉树"><a href="#按之字形顺序打印二叉树" class="headerlink" title="按之字形顺序打印二叉树"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tqId=23454&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">按之字形顺序打印二叉树</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）<br><img src="../../images/%E4%B9%8B%E5%AD%97%E5%BD%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0.png" alt="之字形"></p>
<p>该图打印出来为 {[1], [3,2],[4, 5]};</p>
<h3 id="思路及代码"><a href="#思路及代码" class="headerlink" title="思路及代码"></a>思路及代码</h3><ol>
<li>之字形打印，即层级打印，只是顺序变化而已，那么很容易就想到使用 BFS 来处理</li>
<li>使用队列来处理，这样减少递归的使用</li>
</ol>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/**
 * @param pRoot TreeNode类
 * @return int整型二维数组
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token parameter">pRoot<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span><span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 如果树为空，直接返回空数组</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pRoot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 定义结果二维数组</span>
  <span class="token keyword">const</span> res<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 创建队列</span>
  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 记录当前的层数</span>
  <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 记录这一层的长度</span>
    <span class="token keyword">const</span> length <span class="token operator">=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment">// 创建临时数组，用于接收下一层的数据</span>
    <span class="token keyword">const</span> temp<span class="token operator">:</span> TreeNode<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建一维结果数组，最后直接全量推到结果二维数组中即可</span>
    <span class="token keyword">const</span> cur<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">let</span> curRoot<span class="token punctuation">;</span>
      <span class="token comment">// 这里需要想清楚，由于是之字形，则奇数层的时候怎么处理以及偶数层又要怎么处理</span>
      <span class="token comment">// 由于定义层级从1开始，则开始为奇数层，那么考虑到后续，偶数层变换方向</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 偶数层处理，变换方向，则头部出队</span>
        curRoot <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        curRoot<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curRoot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        curRoot<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curRoot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 奇数层处理，由于偶数层是正向push加入，则之字形的时候，奇数层需要尾部出队</span>
        curRoot <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        curRoot<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>curRoot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        curRoot<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>curRoot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
      cur<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curRoot<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    index <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="双端队列处理"><a href="#双端队列处理" class="headerlink" title="双端队列处理"></a>双端队列处理</h3><ol>
<li>特例处理： 当树的根节点为空，则直接返回空列表 [] ；</li>
<li>初始化： 打印结果空列表 res ，包含根节点的双端队列 deque ；<br>BFS 循环： 当 deque 为空时跳出；<br>新建列表 tmp ，用于临时存储当前层打印结果；</li>
<li>当前层打印循环： 循环次数为当前层节点数（即 deque 长度）；<br>出队： 队首元素出队，记为 node；<br>打印： 若为奇数层，将 node.val 添加至 tmp 尾部；否则，添加至 tmp 头部；<br>添加子节点： 若 node 的左（右）子节点不为空，则加入 deque ；<br>将当前层结果 tmp 转化为 list 并添加入 res ；</li>
<li>返回值： 返回打印结果列表 res 即可；</li>
</ol>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">decorateRecord</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span><span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> res<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> length <span class="token operator">=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">const</span> temp<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">const</span> cur <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        temp<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
      cur<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
      cur<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    index<span class="token operator">++</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>temp<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="二叉搜索树的第-K-个节点"><a href="#二叉搜索树的第-K-个节点" class="headerlink" title="二叉搜索树的第 K 个节点"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/57aa0bab91884a10b5136ca2c087f8ff?tpId=13&tqId=2305268&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉搜索树的第 K 个节点</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵结点数为 n 二叉搜索树，请找出其中的第 k 小的 TreeNode 结点值。 1.返回第 k 小的节点值即可 2.不能查找的情况，如二叉树为空，则返回-1，或者 k 大于 n 等等，也返回-1 3.保证 n 个节点的值不一样</p>
<h3 id="思路及代码-1"><a href="#思路及代码-1" class="headerlink" title="思路及代码"></a>思路及代码</h3><p>方案一(暴力解法)</p>
<ol>
<li>要找第 K 个最小值，很容易想到直接把树遍历，然后取出所有值，再排序一下，然后取 k-1 个值就好</li>
</ol>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/*class TreeNode &#123;
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     &#125;
 * &#125;
 */</span>
<span class="token comment">/**
 * @param proot TreeNode类
 * @param k int整型
 * @return int整型
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">KthNode</span><span class="token punctuation">(</span><span class="token parameter">proot<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> k<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>proot <span class="token operator">||</span> k <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> res<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> treeNodes<span class="token operator">:</span> TreeNode<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>proot<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>treeNodes<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> cur <span class="token operator">=</span> treeNodes<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cur<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> treeNodes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cur<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> treeNodes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">></span> res<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> sort <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> sort<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>方案二(递归中序遍历)</p>
<p>根据二叉搜索树的性质，左子树的元素都小于根节点，右子树的元素都大于根节点。因此它的中序遍历（左中右）序列正好是由小到大的次序，因此我们可以尝试递归中序遍历，也就是从最小的一个节点开始，找到 k 个就是我们要找的目标。</p>
<ol>
<li>设置全局变量 count 记录遍历了多少个节点，res 记录第 k 个节点。</li>
<li>另写一函数进行递归中序遍历，当节点为空或者超过 k 时，结束递归，返回。</li>
<li>优先访问左子树，再访问根节点，访问时统计数字，等于 k 则找到。</li>
<li>最后访问右子树。</li>
</ol>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/*class TreeNode &#123;
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     &#125;
 * &#125;
 */</span>
<span class="token comment">/**
 * @param proot TreeNode类
 * @param k int整型
 * @return int整型
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">KthNode</span><span class="token punctuation">(</span><span class="token parameter">proot<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> k<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>proot <span class="token operator">||</span> k <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">let</span> res<span class="token punctuation">;</span>
  <span class="token comment">// 定义当前的次数</span>
  <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">midOrder</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> count <span class="token operator">></span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">midOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">===</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      res <span class="token operator">=</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">midOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token function">midOrder</span><span class="token punctuation">(</span>proot<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=23282&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">重建二叉树</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。<br>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉树的前序遍历：根左右；中序遍历：左根右<br>由前序遍历知道根节点之后，能在中序遍历上划分出左子树和右子树。分别对中序遍历的左右子树递归进行这一过程即可建树。<br><img src="../../images/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="重建"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/*class TreeNode &#123;
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     &#125;
 * &#125;
 */</span>
<span class="token comment">/**
 * @param preOrder int整型一维数组
 * @param vinOrder int整型一维数组
 * @return TreeNode类
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">reConstructBinaryTree</span><span class="token punctuation">(</span>
  <span class="token parameter">preOrder<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  vinOrder<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> TreeNode <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>preOrder<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>preOrder<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> rootVal <span class="token operator">=</span> preOrder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 从中序遍历结果中找到分割点</span>
  <span class="token keyword">const</span> povitIndex <span class="token operator">=</span> vinOrder<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
  root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">reConstructBinaryTree</span><span class="token punctuation">(</span>
    preOrder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> povitIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    vinOrder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> povitIndex<span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">reConstructBinaryTree</span><span class="token punctuation">(</span>
    preOrder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>povitIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    vinOrder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>povitIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="二叉树的子结构"><a href="#二叉树的子结构" class="headerlink" title="二叉树的子结构"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=23293&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉树的子结构</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树 A，B，判断 B 是不是 A 的子结构。（我们约定空树不是任意一个树的子结构）<br>假如给定 A 为{8,8,7,9,2,#,#,#,#,4,7}，B 为{8,9,2}，2 个树的结构如下，可以看出 B 是 A 的子结构</p>
<p><img src="../../images/%E5%AD%90%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0.png" alt="子结构"></p>
<h3 id="思路-队列"><a href="#思路-队列" class="headerlink" title="思路(队列)"></a>思路(队列)</h3><p>这道题的思路，无非就是在 A 树中遍历每个节点尝试找到那个子树，然后每次以该节点出发能不能将子树与 B 树完全匹配。能用前序遍历解决，我们也可以用层次遍历来解决。<br>首先对于 A 树层次遍历每一个节点，遇到一个与 B 树根节点相同的节点，我们就开始同步层次遍历比较以这个节点为根的树中是否出现了 B 树的全部节点。因为我们只考虑 B 树的所有节点是否在 A 树中全部出现，那我们就以 B 树为基，再进行一次层次遍历，A 树从那个节点开始跟随 B 树一致进行层次遍历就行了，比较对应的每个点是否相同，或者 B 树是否有超出 A 树没有的节点</p>
<ol>
<li>先判断空树，空树不为子结构。</li>
<li>利用队列辅助，层次遍历第一棵树，每次检查遍历到的节点是否和第二棵树的根节点相同。</li>
<li>若是相同，可以以该节点为子树根节点，再次借助队列辅助，同步层次遍历这个子树与第二棵树，这个时候以第二棵树为基，只要找到第二棵树的全部节点，就算找到了子结构。</li>
</ol>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/*class TreeNode &#123;
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     &#125;
 * &#125;
 */</span>

<span class="token comment">/**
 * @param pRoot1 TreeNode类
 * @param pRoot2 TreeNode类
 * @return bool布尔型
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">HasSubtree</span><span class="token punctuation">(</span><span class="token parameter">pRoot1<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> pRoot2<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">&#123;</span>
  <span class="token comment">// B树为空，肯定不是子结构</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pRoot2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// A树为空，B树不为空，也不是子结构</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>pRoot1 <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> pRoot2 <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 检查是否是子结构的方法，队列处理</span>
  <span class="token keyword">const</span> <span class="token function-variable function">checkIsSubTree</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root1<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> root2<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 创建两个队列</span>
    <span class="token keyword">const</span> queue1 <span class="token operator">=</span> <span class="token punctuation">[</span>root1<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> queue2 <span class="token operator">=</span> <span class="token punctuation">[</span>root2<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 这里遍历B树，让A树队列跟随执行即可，减少循环次数</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>queue2<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">const</span> cur1 <span class="token operator">=</span> queue1<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> cur2 <span class="token operator">=</span> queue2<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// A树节点为空，或者两个节点值不等，则肯定不是子结构</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cur1 <span class="token operator">||</span> cur1<span class="token punctuation">.</span>val <span class="token operator">!==</span> cur2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
      <span class="token comment">// 依次入队</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>cur2<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        queue1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur1<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>cur2<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        queue1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur1<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token comment">// 定义A树的队列</span>
  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>pRoot1<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> cur <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 发现当前的值和B树的值相同，进入依次比较</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">===</span> pRoot2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// 这里不能直接返回该方法结果，因为某一个节点值相同，但是子结构还在下面</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">checkIsSubTree</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> pRoot2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    cur<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cur<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="思路-递归"><a href="#思路-递归" class="headerlink" title="思路(递归)"></a>思路(递归)</h3><p>既然是要找到 A 树中是否有 B 树这样子树，如果是有子树肯定是要遍历这个子树和 B 树，将两个的节点一一比较，但是这样的子树不一定就是 A 树根节点开始的，所以我们还要先找到子树可能出现的位置。<br>既然是可能的位置，那我们可以对 A 树的每个节点前序递归遍历，寻找是否有这样的子树，而寻找是否有子树的时候，我们就将 A 树与 B 树同步前序遍历，依次比较节点值。</p>
<ol>
<li>因为空树不是任何树的子树，所以要先判断 B 树是否为空树。</li>
<li>当 A 树为空节点，但是 B 树还有节点的时候，不为子树，但是 A 树不为空节点，B 树为空节点时可以是子树。</li>
<li>每次递归比较 A 树从当前节点开始，是否与 B 树完全一致，同步前序遍历。</li>
<li>A 树自己再前序遍历进入子节点，当作子树起点再与 B 树同步遍历。</li>
<li>以上情况任意只要有一种即可。</li>
</ol>
<p><img src="../../images/%E5%AD%90%E7%BB%93%E6%9E%84%E5%9B%BE%E7%A4%BA.gif" alt="图示"></p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/**
 * @param pRoot1 TreeNode类
 * @param pRoot2 TreeNode类
 * @return bool布尔型
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">HasSubtree</span><span class="token punctuation">(</span><span class="token parameter">pRoot1<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> pRoot2<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">&#123;</span>
  <span class="token comment">// B树不存在，不是子结构</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pRoot2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>pRoot1 <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> pRoot2 <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">checkIsSubTree</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root1<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> root2<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root1 <span class="token operator">&amp;&amp;</span> root2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 任一一个为空了，则说明找到底了</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root1 <span class="token operator">||</span> <span class="token operator">!</span>root2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root1<span class="token punctuation">.</span>val <span class="token operator">!==</span> root2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token function">checkIsSubTree</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
      <span class="token function">checkIsSubTree</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token comment">// 前序遍历，找到其值是否相同</span>
  <span class="token keyword">const</span> checkRes <span class="token operator">=</span> <span class="token function">checkIsSubTree</span><span class="token punctuation">(</span>pRoot1<span class="token punctuation">,</span> pRoot2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> flag1 <span class="token operator">=</span> <span class="token function">HasSubtree</span><span class="token punctuation">(</span>pRoot1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> pRoot2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> flag2 <span class="token operator">=</span> <span class="token function">HasSubtree</span><span class="token punctuation">(</span>pRoot1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> pRoot2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> checkRes <span class="token operator">||</span> flag1 <span class="token operator">||</span> flag2<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=13&tqId=1374963&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉树的镜像</a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<h3 id="思路-递归-1"><a href="#思路-递归-1" class="headerlink" title="思路 (递归)"></a>思路 (递归)</h3><p>因为我们需要将二叉树镜像，意味着每个左右子树都会交换位置，如果我们从上到下对遍历到的节点交换位置，但是它们后面的节点无法跟着他们一起被交换，因此我们可以考虑自底向上对每两个相对位置的节点交换位置，这样往上各个子树也会被交换位置。<br>自底向上的遍历方式，我们可以采用后序递归的方法。</p>
<ol>
<li>先深度最左端的节点，遇到空树返回，处理最左端的两个子节点交换位置。</li>
<li>然后进入右子树，继续按照先左后右再回中的方式访问。</li>
<li>再返回到父问题，交换父问题两个子节点的值。</li>
</ol>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/*class TreeNode &#123;
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     &#125;
 * &#125;
 */</span>
<span class="token comment">/**
 * @param pRoot TreeNode类
 * @return TreeNode类
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">Mirror</span><span class="token punctuation">(</span><span class="token parameter">pRoot<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span><span class="token operator">:</span> TreeNode <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pRoot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">Mirror</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">Mirror</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  pRoot<span class="token punctuation">.</span>left <span class="token operator">=</span> right<span class="token punctuation">;</span>
  pRoot<span class="token punctuation">.</span>right <span class="token operator">=</span> left<span class="token punctuation">;</span>
  <span class="token keyword">return</span> pRoot<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="思路（栈的方式）"><a href="#思路（栈的方式）" class="headerlink" title="思路（栈的方式）"></a>思路（栈的方式）</h3><p>二叉树中能够用递归的，我们大多也可以用栈来实现。栈的访问是一种自顶向下的访问，因此我们需要在左右子节点入栈后直接交换，然后再访问后续栈中内容。</p>
<ol>
<li>优先检查空树的情况。</li>
<li>使用栈辅助遍历二叉树，根节点先进栈。</li>
<li>遍历过程中每次弹出栈中一个元素，然后该节点左右节点分别入栈。</li>
<li>同时我们交换入栈两个子节点的值，因为子节点已经入栈了再交换，就不怕后续没有交换。</li>
</ol>
<p><img src="../../images/%E9%95%9C%E5%83%8F%E6%A0%88%E5%A4%84%E7%90%86.gif" alt="栈处理"></p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/**
 * @param pRoot TreeNode类
 * @return TreeNode类
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">Mirror</span><span class="token punctuation">(</span><span class="token parameter">pRoot<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span><span class="token operator">:</span> TreeNode <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pRoot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 入栈</span>
  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 出栈</span>
    <span class="token keyword">const</span> cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cur<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cur<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 这里就是交换</span>
    <span class="token keyword">const</span> left <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    cur<span class="token punctuation">.</span>left <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    cur<span class="token punctuation">.</span>right <span class="token operator">=</span> left<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> pRoot<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="二叉树中和为某一值的路径（一）"><a href="#二叉树中和为某一值的路径（一）" class="headerlink" title="二叉树中和为某一值的路径（一）"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/508378c0823c423baa723ce448cbfd0c?tpId=13&tqId=634&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉树中和为某一值的路径（一）</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树 root 和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。 1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点 2.叶子节点是指没有子节点的节点 3.路径只能从父节点到子节点，不能从子节点到父节点 4.总节点数目为 n</p>
<h3 id="思路（递归）"><a href="#思路（递归）" class="headerlink" title="思路（递归）"></a>思路（递归）</h3><p>既然要找有没有路径的和为给定 sum 值，则只需要从根节点遍历到底节点，然后计算即可</p>
<ol>
<li>首先判断树是否为空，为空直接返回 false</li>
<li>然后进行 DFS 递归，每进入下一个节点，将 sum 减去当前节点值 diff 传入下去</li>
<li>注意几个边界，当 diff 小于 0 并且没有左右子节点，则直接返回 false,只有当 diff 为 0 并且左右子节点为空，这时候才存在该路径</li>
</ol>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/**
 * @param root TreeNode类
 * @param sum int整型
 * @return bool布尔型
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">&#123;</span>
  <span class="token comment">// 树为空，直接返回false</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 当到达最底层节点，并且当前sum不为0, 则该路径不是</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root <span class="token operator">&amp;&amp;</span> sum <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> notChild <span class="token operator">=</span> <span class="token operator">!</span>root<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token comment">// 每次减去当前层级节点值</span>
  <span class="token keyword">const</span> diff <span class="token operator">=</span> sum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
  <span class="token comment">// 差值小于0，并且没有子节点，则该路径不符合</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> notChild<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 没有子节点，并且差值为0，则该路径符合</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> notChild<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 进行递归</span>
  <span class="token keyword">const</span> flag <span class="token operator">=</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> diff<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> flag1 <span class="token operator">=</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> diff<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> flag <span class="token operator">||</span> flag1<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="思路（栈处理）"><a href="#思路（栈处理）" class="headerlink" title="思路（栈处理）"></a>思路（栈处理）</h3><p>在二叉树中能够用递归解决的问题，很多时候我们也可以用非递归来解决。这里遍历过程也可以使用栈辅助，进行 dfs（深度优先搜索）遍历，检查往下的路径中是否有等于 sum 的路径和。<br>注意，这里仅是 dfs，而不是前序遍历，左右节点的顺序没有关系，因为每次往下都是单独添加某个节点的值相加然后继续往下，因此左右节点谁先遍历不管用。</p>
<ol>
<li>首先检查空节点，空树没有路径。</li>
<li>使用两个栈同步遍历，一个栈记录节点，辅助深度优先搜索，另一个栈跟随记录到该节点为止的路径和。根节点及根节点值先进栈。</li>
<li>遍历的时候每次弹出两个栈中的内容，判断是否是叶子节点且路径和是否等于目标值。</li>
<li>没有到叶子节点就将左右子节点（如果有）加入栈中，并跟随加入路径和。</li>
<li>如果遍历结束也没有找到路径和，则该二叉树中没有。</li>
</ol>
<p><img src="../../images/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E7%9A%84%E8%B7%AF%E5%BE%84.gif" alt="图示"></p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/**
 * @param root TreeNode类
 * @param sum int整型
 * @return bool布尔型
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">&#123;</span>
  <span class="token comment">// 树为空，返回false</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 树节点栈</span>
  <span class="token keyword">const</span> rootStack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 节点和的栈，辅助记录走到当前节点的和为多少</span>
  <span class="token keyword">const</span> sumStack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>rootStack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 树与和都出栈</span>
    <span class="token keyword">const</span> curRoot <span class="token operator">=</span> rootStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> curSum <span class="token operator">=</span> sumStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 当和为sum,并且没有左右子几点，则路径存在</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>curRoot<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>curRoot<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> curSum <span class="token operator">===</span> sum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>curRoot<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      rootStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curRoot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
      sumStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curSum <span class="token operator">+</span> curRoot<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>curRoot<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      rootStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curRoot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
      sumStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curSum <span class="token operator">+</span> curRoot<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="二叉树中和为某一值的路径（二）"><a href="#二叉树中和为某一值的路径（二）" class="headerlink" title="二叉树中和为某一值的路径（二）"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&tqId=23276&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉树中和为某一值的路径（二）</a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一颗二叉树的根节点 root 和一个整数 expectNumber，找出二叉树中结点值的和为 expectNumber 的所有路径。 1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点 2.叶子节点是指没有子节点的节点 3.路径只能从父节点到子节点，不能从子节点到父节点 4.总节点数目为 n</p>
<h3 id="思路（递归-Dfs）"><a href="#思路（递归-Dfs）" class="headerlink" title="思路（递归 Dfs）"></a>思路（递归 Dfs）</h3><p>既然是要找出所有和为 expectNumber 的路径，则需要记录每次相加和为 expectNumber 的值，<br>那么这里使用 dfs 递归查找，每次递归都传递一个 temp 数组，查找到是该路径，则加入该数组</p>
<ol>
<li>首先判断树是否为空，为空则直接返回[]</li>
<li>记录一个临时路径数组，并且每次递归的时候传入</li>
<li>每次执行到一个节点，都将节点加入 temp 数组，并且用当前 diff 减去当前节点值</li>
<li>如果 diff 值为 0，并且左右子节点为空，则该路径符合</li>
</ol>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/**
 * @param root TreeNode类
 * @param target int整型
 * @return int整型二维数组
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">FindPath</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> target<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 树为空，返回空数组</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 创建结果数组</span>
  <span class="token keyword">const</span> res<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 创建dfs方法，该方法接受三个入参，当前树，diff差值，临时路径存储数组</span>
  <span class="token keyword">const</span> <span class="token function-variable function">Dfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">tree<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> diff<span class="token operator">:</span> number<span class="token punctuation">,</span> temp<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// dfs中树为空，则退出</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 是否有子节点标识</span>
    <span class="token keyword">const</span> notChild <span class="token operator">=</span> <span class="token operator">!</span>tree<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token comment">// 当前差值</span>
    <span class="token keyword">const</span> curDiff <span class="token operator">=</span> diff <span class="token operator">-</span> tree<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
    <span class="token comment">// 当前差值小于0，并且没有子节点，退出</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>curDiff <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> notChild<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 将当前节点值，加入路径数组</span>
    temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 差值为0，并且没有左右子节点，则将路径加入结果数组</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>curDiff <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> notChild<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// 注意，这里使用解构，是由于js中数组传递是引用传递，这里不能直接使用引用，下面递归的时候同理</span>
      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>temp<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Dfs</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">,</span> curDiff<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">...</span>temp<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Dfs</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">,</span> curDiff<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">...</span>temp<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token function">Dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="二叉树和为某一路径（三）"><a href="#二叉树和为某一路径（三）" class="headerlink" title="二叉树和为某一路径（三）"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/965fef32cae14a17a8e86c76ffe3131f?tpId=13&tqId=2277604&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉树和为某一路径（三）</a></h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树 root 和一个整数值 sum ，求该树有多少路径的的节点值之和等于 sum 。 1.该题路径定义不需要从根节点开始，也不需要在叶子节点结束，但是一定是从父亲节点往下到孩子节点 2.总节点数目为 n 3.保证最后返回的路径个数在整形范围内</p>
<p><img src="../../images/%E4%B8%89.png" alt="&#39;&#39;"></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>既然要找所有路径上节点和等于目标值的路径个数，那我们肯定先找这样的路径起点啊，但是我们不知道起点究竟在哪里，而且任意节点都有可能是起点，那我们就前序遍历二叉树的所有节点，每个节点都可以作为一次起点，即子树的根节点。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//以其子结点为新根</span>
<span class="token function">FindPath</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">FindPath</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>查找路径的时候呢，也需要往下遍历，因此还可以继续前序遍历该子树，在遍历的过程遇到一个节点，sum 相应减少，若是到最后往下的一个节点值正好等于剩下的 sum，则找到一种情况。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//符合目标值</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> res<span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>因为前序递归的次序是根左右，因此一定是往下找的路径，不会往上回溯。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//进入子节点继续找</span>
<span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sum <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ol>
<li>每次将原树中遇到的节点作为子树的根节点送入 dfs 函数中查找有无路径，如果该节点为空则返回。</li>
<li>然后递归遍历这棵树每个节点，每个节点都需要这样操作。</li>
<li>在 dfs 函数中，也是往下递归，遇到一个节点就将 sum 减去节点值再往下。</li>
<li>剩余的 sum 等于当前节点值则找到一种情况。</li>
</ol>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/**
 * @param root TreeNode类
 * @param sum int整型
 * @return int整型
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">FindPath</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> sum<span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">Dfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">tree<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> diff<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">===</span> tree<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      ans<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    ans <span class="token operator">+=</span> <span class="token function">Dfs</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">,</span> diff <span class="token operator">-</span> tree<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ans <span class="token operator">+=</span> <span class="token function">Dfs</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">,</span> diff <span class="token operator">-</span> tree<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token comment">//查询以某结点为根的路径数</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token function">Dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//以其子结点为新根</span>
  res <span class="token operator">+=</span> <span class="token function">FindPath</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
  res <span class="token operator">+=</span> <span class="token function">FindPath</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="判断是否是平衡二叉树"><a href="#判断是否是平衡二叉树" class="headerlink" title="判断是否是平衡二叉树"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&tqId=23250&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">判断是否是平衡二叉树</a></h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。<br>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树<br>平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>直接再求高度的同时，直接判断当前层级的高度是否大于 1 即可<br>首先这里要注意一点是 “高度差” 不是左右节点值的差值</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/**
 * @param pRoot TreeNode类
 * @return bool布尔型
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">IsBalanced_Solution</span><span class="token punctuation">(</span><span class="token parameter">pRoot<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">&#123;</span>
  <span class="token comment">// 空树则是平衡二叉树</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pRoot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 获取树的高度</span>
  <span class="token keyword">const</span> <span class="token function-variable function">getDepth</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">getDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">getDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token comment">// 拿到层级的高度</span>
  <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">getDepth</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">getDepth</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 如果高度差大于1，则不是平衡二叉树</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>left <span class="token operator">-</span> right<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 进行递归</span>
  <span class="token keyword">return</span> <span class="token function">IsBalanced_Solution</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">IsBalanced_Solution</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=23451&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">二叉树的下一个节点</a></h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的 next 指针。下图为一棵有 9 个节点的二叉树。树中从父节点指向子节点的指针用实线表示，从子节点指向父节点的用虚线表示</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>由于给定的只是树中的一个节点，那么这个节点可能是头结点，也可能不是头结点，所以第一步就是要去找到该树的头结点，然后中序遍历，并且<br>在记录中序遍历的结果，然后在中序遍历结果中找到给定的节点，再取出下一个返回即可</p>
<ol>
<li>找出树的头节点</li>
<li>创建一个中序结果数组，然后进行中序遍历，将中序遍历加入该结果</li>
<li>在中序遍历结果中，找到给定的节点</li>
<li>返回下一个节点即可</li>
</ol>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/*class TreeLinkNode &#123;
 *     val: number
 *     left: TreeLinkNode | null
 *     right: TreeLinkNode | null
 *     next: TreeLinkNode | null
 *     constructor(val?: number, left?: TreeLinkNode | null, right?: TreeLinkNode | null, next?: TreeLinkNode | null) &#123;
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *         this.next = (next===undefined ? null : right)
 *     &#125;
 * &#125;
 */</span>
<span class="token comment">/**
 * @param pNode TreeLinkNode类
 * @return TreeLinkNode类
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">GetNext</span><span class="token punctuation">(</span><span class="token parameter">pNode<span class="token operator">:</span> TreeLinkNode</span><span class="token punctuation">)</span><span class="token operator">:</span> TreeLinkNode <span class="token punctuation">&#123;</span>
  <span class="token comment">// 定义临时指针</span>
  <span class="token keyword">let</span> root <span class="token operator">=</span> pNode<span class="token punctuation">;</span>
  <span class="token comment">// 创建中序遍历结果</span>
  <span class="token keyword">const</span> nodes<span class="token operator">:</span> TreeLinkNode<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 找到树的头结点，如果是头结点，则next指针肯定为空</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    root <span class="token operator">=</span> root<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 中序遍历</span>
  <span class="token keyword">const</span> <span class="token function-variable function">InOrder</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">tree<span class="token operator">:</span> TreeLinkNode</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">InOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    nodes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">InOrder</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token function">InOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 在中序遍历结果中找到给定节点</span>
  <span class="token keyword">const</span> index <span class="token operator">=</span> nodes<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">===</span> pNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 返回下一节点</span>
    <span class="token keyword">return</span> nodes<span class="token punctuation">[</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tqId=23452&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">对称的二叉树</a></h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）</p>
<h3 id="思路（递归）-1"><a href="#思路（递归）-1" class="headerlink" title="思路（递归）"></a>思路（递归）</h3><p>判断是否是一颗对称的二叉树，即判断 左节点是否等于右支的右节点</p>
<ol>
<li>两种方向的前序遍历，同步过程中的当前两个节点，同为空，属于对称的范畴。</li>
<li>当前两个节点只有一个为空或者节点值不相等，已经不是对称的二叉树了。</li>
<li>第一个节点的左子树与第二个节点的右子树同步递归对比，第一个节点的右子树与第二个节点的左子树同步递归比较。</li>
</ol>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/**
 * @param pRoot TreeNode类
 * @return bool布尔型
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">isSymmetrical</span><span class="token punctuation">(</span><span class="token parameter">pRoot<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">&#123;</span>
  <span class="token comment">// 树为空，则任务是对称的</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pRoot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">Dfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">lTree<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> rTree<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 左树与右树都为空，则是对称的</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lTree <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>rTree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">//只有一个为空或者节点值不同，必定不对称</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lTree <span class="token operator">||</span> <span class="token operator">!</span>rTree <span class="token operator">||</span> lTree<span class="token punctuation">.</span>val <span class="token operator">!==</span> rTree<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">//每层对应的节点进入递归比较</span>
    <span class="token keyword">return</span> <span class="token function">Dfs</span><span class="token punctuation">(</span>lTree<span class="token punctuation">.</span>left<span class="token punctuation">,</span> rTree<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">Dfs</span><span class="token punctuation">(</span>lTree<span class="token punctuation">.</span>right<span class="token punctuation">,</span> rTree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">Dfs</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">.</span>left<span class="token punctuation">,</span> pRoot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="思路（队列）"><a href="#思路（队列）" class="headerlink" title="思路（队列）"></a>思路（队列）</h3><p>除了递归以外，我们还可以观察，对称的二叉树每一层都是回文的情况，即两边相互对应相等，有节点值的对应节点值，没有节点的连空节点都是对应着的呢。那我们从左往右遍历一层（包括空节点），和从右往左遍历一层（包括空节点）。</p>
<p>这时候二叉树每一层的遍历，我就需要用到了层次遍历。层次遍历从左往右经过第一层后，怎么进入第二层？我们可以借助队列——一个先进先出的容器，在遍历第一层的时候，将第一层节点的左右节点都加入到队列中，因为加入队列的顺序是遍历的顺序且先左后右，也就导致了我从队列出来的时候也是下一层的先左后右，正好一一对应。更巧的是，如果我们要从右到左遍历一层，加入队列后也是先右后左，简直完美对应！</p>
<ol>
<li>首先判断链表是否为空，空链表直接就是对称。</li>
<li>准备两个队列，分别作为从左往右层次遍历和从右往左层次遍历的辅助容器，初始第一个队列加入左节点，第二个队列加入右节点。</li>
<li>循环中每次从队列分别取出一个节点，如果都为空，暂时可以说是对称的，进入下一轮检查；如果某一个为空或是两个节点值不同，那必定不对称。其他情况暂时对称，可以依次从左往右加入子节点到第一个队列，从右往左加入子节点到第二个队列。（这里包括空节点）</li>
<li>遍历结束也没有检查到不匹配，说明就是对称的。</li>
</ol>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/**
 * @param pRoot TreeNode类
 * @return bool布尔型
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">isSymmetrical</span><span class="token punctuation">(</span><span class="token parameter">pRoot<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pRoot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> leftTreeQueue <span class="token operator">=</span> <span class="token punctuation">[</span>pRoot<span class="token punctuation">.</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> rightTreeQueue <span class="token operator">=</span> <span class="token punctuation">[</span>pRoot<span class="token punctuation">.</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>leftTreeQueue<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> rightTreeQueue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//分别从左边和右边弹出节点</span>
    <span class="token keyword">const</span> leftTree <span class="token operator">=</span> leftTreeQueue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> rightTree <span class="token operator">=</span> rightTreeQueue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//都为空暂时对称</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>leftTree <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>rightTree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">//某一个为空或者数字不相等则不对称</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>leftTree <span class="token operator">||</span> <span class="token operator">!</span>rightTree <span class="token operator">||</span> leftTree<span class="token punctuation">.</span>val <span class="token operator">!==</span> rightTree<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">//从左往右加入队列</span>
    leftTreeQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>leftTree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    leftTreeQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>leftTree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//从右往左加入队列</span>
    rightTreeQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>rightTree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    rightTreeQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>rightTree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="把二叉树打印成多行"><a href="#把二叉树打印成多行" class="headerlink" title="把二叉树打印成多行"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&tqId=23453&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">把二叉树打印成多行</a></h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个节点数为 n 二叉树，要求从上到下按层打印二叉树的 val 值，同一层结点从左至右输出，每一层输出一行，将输出的结果存放到一个二维数组中返回。</p>
<h3 id="思路（队列）-1"><a href="#思路（队列）-1" class="headerlink" title="思路（队列）"></a>思路（队列）</h3><p>这里是按层打印，所以很容易想到使用 BFS 来做处理，这里直接用队列处理</p>
<ol>
<li>创建一个队列，加入树头节点。</li>
<li>循环队列，每一层在该循环里面再一次加入</li>
</ol>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/**
 * @param pRoot TreeNode类
 * @return int整型二维数组
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token parameter">pRoot<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span><span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 创建结果数组</span>
  <span class="token keyword">const</span> res<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pRoot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 创建树队列</span>
  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> temp<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> length <span class="token operator">=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment">// 每层循环</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">const</span> cur <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
      cur<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
      cur<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="思路（BFS-递归）"><a href="#思路（BFS-递归）" class="headerlink" title="思路（BFS 递归）"></a>思路（BFS 递归）</h3><p>除了用队列非递归可以实现二叉树的层次遍历，我们也可以使用递归。但是递归前序遍历访问二叉树不是按照层次的顺序，但是因为“根左右”的次序，我们能保证每一层一定左边的元素先访问，后面再访问到同一层右边的元素。</p>
<ol>
<li>记录输出的二维数组初始化为空，每到一层里面填出一个一维数组。</li>
<li>从根节点开始，深度为 1 开始进行递归，当前节点有值递归内容才继续进行，否则返回。</li>
<li>如果记录输出的二维数组长度小于当前层数，说明要新到了一层，我们新开辟一个一维数组加到最后。</li>
<li>因为“根左右”的顺序，同一层左边必定先访问，只需要根据层数在二维数组中找到相应的行号，添加在该行末尾就一定是层次遍历的次序。</li>
</ol>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/**
 * @param pRoot TreeNode类
 * @return int整型二维数组
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token parameter">pRoot<span class="token operator">:</span> TreeNode</span><span class="token punctuation">)</span><span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> res<span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pRoot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">Bfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root<span class="token operator">:</span> TreeNode<span class="token punctuation">,</span> level<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 树为空，退出</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 当结果数组长度小于当前层级，则表示进入下一层了，这时候给下一层一个空数组默认值</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> level<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      res<span class="token punctuation">[</span>level <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 因为层级是从1开始，所以要减一，每层加入当前树的值</span>
    res<span class="token punctuation">[</span>level <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 进入下一层，层级+1</span>
    <span class="token function">Bfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Bfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token function">Bfs</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="求二叉搜索树的最近公共祖先"><a href="#求二叉搜索树的最近公共祖先" class="headerlink" title="求二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree">求二叉搜索树的最近公共祖先</a></h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="../../images/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.png" alt="&#39;&#39;">;</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>若 root 是 p,q 的 最近公共祖先 ，则只可能为以下三种情况之一：</p>
<ol>
<li>p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；</li>
<li>p=root 且 q 在 root 的左或右子树中；</li>
<li>q=root 且 p 在 root 的左或右子树中；</li>
</ol>
<p><img src="../../images/%E4%BA%8C%E5%8F%89%E6%A0%91/ex.png" alt="&#39;&#39;"></p>
<p>本题给定了两个重要条件：<br>① 树为 二叉搜索树 ，<br>② 树的所有节点的值都是 唯一 的。<br>根据以上条件，可方便地判断 p,q 与 root 的子树关系，即：</p>
<ol>
<li>若 root.val &lt; p.val ，则 p 在 root 右子树 中；</li>
<li>若 root.val &gt; p.val ，则 p 在 root 左子树 中；</li>
<li>若 root.val = p.val ，则 p 和 root 指向 同一节点;</li>
</ol>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>循环搜索：</p>
<ol>
<li>当节点 root 为空时跳出；当 p,q 都在 root 的 右子树 中，则遍历至 root.right ；<br>否则，当 p,q 都在 root 的 左子树 中，则遍历至 root.left ；<br>否则，说明找到了 最近公共祖先 ，跳出；</li>
<li>返回值： 最近公共祖先 root ；</li>
</ol>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>
  <span class="token parameter">root<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  p<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  q<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// p、 q都在树的右边</span>
      root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// p、q都在树的左边</span>
      root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="优化方法一"><a href="#优化方法一" class="headerlink" title="优化方法一"></a>优化方法一</h3><p>若可保证 p.val &lt; q.val ，则在循环中可减少判断条件，提升计算效率。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>
  <span class="token parameter">root<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  p<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  q<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>val <span class="token operator">></span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 交换，保证p 小于q</span>
    <span class="token keyword">const</span> temp <span class="token operator">=</span> p<span class="token punctuation">;</span>
    q <span class="token operator">=</span> p<span class="token punctuation">;</span>
    p <span class="token operator">=</span> temp<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// p、 q都在树的右边</span>
      root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// p、q都在树的左边</span>
      root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递推工作：<br>当 p,q 都在 root 的 右子树 中，则开启递归 root.right 并返回；否则，当 p,q 都在 root 的 左子树 中，则开启递归 root.left 并返回；返回值： 最近公共祖先 root；</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>
  <span class="token parameter">root<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  p<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  q<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="寻找二叉树的最近公共祖先"><a href="#寻找二叉树的最近公共祖先" class="headerlink" title="寻找二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree">寻找二叉树的最近公共祖先</a></h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>这个与二叉搜索树的最近公共祖先类似，但是由于树不是二叉搜索树，所以无法根据值的大小做判断<br>所以如下图所示<br><img src="../../images/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E8%A7%A3%E6%9E%90.png" alt="&#39;&#39;"></p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>
  <span class="token parameter">root<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  p<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  q<span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> TreeNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root <span class="token operator">||</span> root <span class="token operator">===</span> p <span class="token operator">||</span> root <span class="token operator">===</span> q<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>left<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> right<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> left<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">CrownNight</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://crownnight.github.io/2023/er-cha-shu-xiang-guan/">https://crownnight.github.io/2023/er-cha-shu-xiang-guan/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">CrownNight</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/JavaScript/">
                                    <span class="chip bg-color">JavaScript</span>
                                </a>
                            
                                <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">
                                    <span class="chip bg-color">二叉树</span>
                                </a>
                            
                                <a href="/tags/%E6%A0%91/">
                                    <span class="chip bg-color">树</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="facebook,google,qq,qzone,wechat,douban" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/sou-suo-yu-hui-su/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="搜索与回溯">
                        
                        <span class="card-title">搜索与回溯</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-09-22
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="post-category">
                                    数据结构与算法
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JavaScript/">
                        <span class="chip bg-color">JavaScript</span>
                    </a>
                    
                    <a href="/tags/%E6%90%9C%E7%B4%A2/">
                        <span class="chip bg-color">搜索</span>
                    </a>
                    
                    <a href="/tags/%E5%9B%9E%E6%BA%AF/">
                        <span class="chip bg-color">回溯</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/pan-duan-zi-fu-chuan-you-xiao-gua-hao/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/4.jpg" class="responsive-img" alt="判断字符串有效括号">
                        
                        <span class="card-title">判断字符串有效括号</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-08-01
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="post-category">
                                    数据结构与算法
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JavaScript/">
                        <span class="chip bg-color">JavaScript</span>
                    </a>
                    
                    <a href="/tags/leetcode/">
                        <span class="chip bg-color">leetcode</span>
                    </a>
                    
                    <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/">
                        <span class="chip bg-color">字符串</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2024</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">CrownNight</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2021";
                    var startMonth = "10";
                    var startDate = "8";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/CrownNight" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:596033486@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>




    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=596033486" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 596033486" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
